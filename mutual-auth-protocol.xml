<?xml version="1.0" encoding="US-ASCII" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC1939 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1939.xml">
<!ENTITY RFC2104 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2818 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2818.xml">
<!ENTITY RFC2898 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2898.xml">
<!ENTITY RFC3629 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3629.xml">
<!ENTITY RFC4013 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4013.xml">
<!ENTITY RFC4648 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC5226 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC5234 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY RFC5246 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5890 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5890.xml">
<!ENTITY RFC5929 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5929.xml">
<!ENTITY RFC5987 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5987.xml">
<!ENTITY RFC6265 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6265.xml">
<!ENTITY RFC6454 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6454.xml">
<!ENTITY RFC7230 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml">
<!ENTITY RFC7235 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7235.xml">
<!ENTITY RFC7564 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7564.xml">
<!ENTITY RFC7613 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7613.xml">
<!ENTITY RFC7615 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7615.xml">
<!ENTITY RFC7616 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7616.xml">
<!ENTITY RFC7627 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7627.xml">
<!-- ENTITY FIPS.186-3.2009 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml2/reference.FIPS.186-3.2009.xml" -->
<!ENTITY ISO.10646-1.1993 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml2/reference.ISO.10646-1.1993.xml">
<!ENTITY ITU.X690.1994 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml2/reference.ITU.X690.1994">
<!ENTITY OASIS.saml-core-2.0-os SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml">
<!ENTITY I-D.ietf-httpauth-mutual-algo SYSTEM "mutual-auth-algorithms-ref.xml">
<!ENTITY I-D.ietf-httpauth-extension SYSTEM "http-auth-extension-ref.xml">
<!-- entities for RFC requirement keywords -->
<!ENTITY MUST "MUST">
<!ENTITY MUST_NOT "MUST&nbsp;NOT">
<!ENTITY SHALL "SHALL">
<!ENTITY SHALL_NOT "SHALL&nbsp;NOT">
<!ENTITY REQUIRED "REQUIRED">
<!ENTITY SHOULD "SHOULD">
<!ENTITY SHOULD_NOT "SHOULD&nbsp;NOT">
<!ENTITY RECOMMENDED "RECOMMENDED">
<!ENTITY NOT_RECOMMENDED "NOT&nbsp;RECOMMENDED">
<!ENTITY OPTIONAL "OPTIONAL">
<!ENTITY MAY "MAY">

<!-- additional generic entities -->
<!ENTITY minus "&nbhy;">

<!-- protocol-specific entities -->
<!ENTITY _Protocol_version_token "-wg-draft04">

<!ENTITY _401-INIT "401&nbhy;INIT">
<!ENTITY _401-STALE "401&nbhy;STALE">
<!ENTITY _req-KEX-C1 "req&nbhy;KEX&nbhy;C1">
<!ENTITY _401-KEX-S1 "401&nbhy;KEX&nbhy;S1">
<!ENTITY _req-VFY-C "req&nbhy;VFY&nbhy;C">
<!ENTITY _200-VFY-S "200&nbhy;VFY&nbhy;S">
<!ENTITY _Authentication-Info "Authentication&nbhy;Info">
<!ENTITY _WWW-Authenticate "WWW&nbhy;Authenticate">
<!ENTITY _Optional-WWW-Authenticate "Optional&nbhy;&_WWW-Authenticate;">
<!ENTITY _Authentication-Control "Authentication&nbhy;Control">
<!ENTITY _Authorization "Authorization">
<!ENTITY _tls-unique "tls&nbhy;unique">
<!ENTITY _tls-server-end-point "tls&nbhy;server&nbhy;end&nbhy;point">
<!ENTITY _auth-scope "auth&nbhy;domain">
<!ENTITY _auth-scheme "auth&nbhy;scheme">
<!ENTITY _nc-max "nc&nbhy;max">
<!ENTITY _nc-window "nc&nbhy;window">
<!ENTITY _logout-timeout "logout&nbhy;timeout">
<!ENTITY _100-continue "100&nbhy;continue">

<!ENTITY _S_c1 "S_c1">
<!ENTITY _S_s1 "S_s1">
<!ENTITY _K_c1 "K_c1">
<!ENTITY _K_s1 "K_s1">
<!ENTITY _kc1 "kc1">
<!ENTITY _ks1 "ks1">
<!ENTITY _VK_c "VK_c">
<!ENTITY _VK_s "VK_s">
<!ENTITY _vkc "vkc">
<!ENTITY _vks "vks">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<!-- Comment out this before submission: 
     single hyphen below for submission, double hyphens for interim drafts 
     -->
<?rfc private='Interim Draft draft-ietf-httpauth-mutualauth-06.1 (C) Yutaka Oiwa, et al.' ?>
<?rfc header='' ?>
<?rfc footer='Interim Draft' ?>
<!-- -->

<rfc category="exp" docName="draft-ietf-httpauth-mutual-06" ipr="trust200902">

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <title abbrev="Mutual Authentication Protocol for HTTP">Mutual Authentication Protocol for HTTP</title>

    <author fullname="Yutaka Oiwa" initials="Y." surname="Oiwa">
      <organization abbrev="ITRI, AIST">National Institute of Advanced Industrial Science and Technology</organization>

      <address>
        <postal>
          <street>Information Technology Research Institute</street>
          <street>Tsukuba Central 1</street>
          <street>1-1-1 Umezono</street>
          <city>Tsukuba-shi</city><region>Ibaraki</region>
          <country>JP</country>
        </postal>

        <email>mutual-auth-contact-ml@aist.go.jp</email>
      </address>
    </author>

    <author fullname="Hajime Watanabe" initials="H." surname="Watanabe">
      <organization abbrev="ITRI, AIST">National Institute of Advanced Industrial Science and Technology</organization>
      <address>
        <postal>
          <street>Information Technology Research Institute</street>
          <street>Tsukuba Central 1</street>
          <street>1-1-1 Umezono</street>
          <city>Tsukuba-shi</city><region>Ibaraki</region>
          <country>JP</country>
        </postal>
      </address>
    </author>

    <author fullname="Hiromitsu Takagi" initials="H." surname="Takagi">
      <organization abbrev="ITRI, AIST">National Institute of Advanced Industrial Science and Technology</organization>
      <address>
        <postal>
          <street>Information Technology Research Institute</street>
          <street>Tsukuba Central 1</street>
          <street>1-1-1 Umezono</street>
          <city>Tsukuba-shi</city><region>Ibaraki</region>
          <country>JP</country>
        </postal>
      </address>
    </author>

    <author fullname="Kaoru Maeda" initials="K." surname="Maeda">
      <organization abbrev="Lepidum">Lepidum Co. Ltd.</organization>
      <address>
        <postal>
          <street>Village Sasazuka 3, Suite #602</street>
	  <street>1-30-3 Sasazuka</street>
          <city>Shibuya-ku</city><region>Tokyo</region>
          <country>JP</country>
        </postal>
      </address>
    </author>

    <author fullname="Tatsuya Hayashi" initials="T." surname="Hayashi">
      <organization abbrev="Lepidum">Lepidum Co. Ltd.</organization>
      <address>
        <postal>
          <street>Village Sasazuka 3, Suite #602</street>
	  <street>1-30-3 Sasazuka</street>
          <city>Shibuya-ku</city><region>Tokyo</region>
          <country>JP</country>
        </postal>
      </address>
    </author>

    <author fullname="Yuichi Ioku" initials="Y." surname="Ioku">
      <organization abbrev="Individual">Individual</organization>
    </author>

    <date /> <!-- year="2011" /> -->

    <!-- Meta-data Declarations -->

    <area>Security</area>
    <workgroup>HTTPAUTH Working Group</workgroup>

    <keyword>HTTP, authentication</keyword>

    <abstract>
      <t><!-- Thanks Peter Saint-Andre for rephrasing -->
   This document specifies a mutual authentication scheme for
   the Hypertext Transfer Protocol (HTTP).  This scheme provides true
   mutual authentication between an HTTP client and an HTTP server
   using password-based authentication.  Unlike the Basic and Digest
   authentication schemes, the Mutual authentication scheme specified
   in this document assures the user that the server truly knows the
   user's encrypted password.
      </t>
    </abstract>
  </front>

<middle>

<section title="Introduction">

     <t>This document specifies a mutual authentication scheme for
     Hypertext Transfer Protocol (HTTP).  The scheme, called
     "Mutual Authentication Protocol" in this document, provides
     true mutual authentication between an HTTP client and an
     HTTP server, using just a simple password as a credential.
     </t>

     <t>
     The authentication scheme proposed in this document 
     is a general framework for using password-based authenticated key exchange (PAKE)
     and similar stronger cryptographic primitives with HTTP.
     It has the following main characteristics:

     <list style="symbols">
	  <t>It provides "true" mutual authentication: in addition to
             assuring the server that the user knows the password, it
             also assures the user that the server truly knows the
             user's encrypted password at the same time.  This makes
             it impossible for fake website owners to persuade users that
             they have authenticated with the original websites.</t>
          <t>It uses only passwords as the user's credential: unlike
             public-key-based security algorithms, the scheme does not
             rely on secret keys or other cryptographic data that have
             to be stored inside the users' computers.  The proposed scheme can
             be used as a drop-in replacement to the current
             authentication schemes like Basic or Digest, while ensuring
             a much stronger level of security.</t>
	  <t>It is secure: when the server fails to authenticate with a user,
             the protocol will not reveal the tiniest bit of
             information about the user's password.</t>
     </list>
     </t>

     <!-- t>
        The document, along with <xref target="I-D.ietf-httpauth-extension"/>,
        also proposes several extensions to the current
        HTTP authentication framework, to provide Web developers
	an option to replace current widely-used form-based Web authentication
	with the cryptographically-strong authentication mechanism.
        The extensions provided include:
        <list style="symbols">
	  <t>Multi-host single authentication within an Internet domain (<xref target="authrealm" />),</t>
	  <t>non-mandatory, optional authentication on HTTP,</t>
	  <t>log out from both server and client side, and</t>
	  <t>finer control for redirection depending on authentication status.</t>
      </list>
     </t -->

  <section title="Terminology">

    <t>The key words "&MUST;", "&MUST_NOT;", "&REQUIRED;", "&SHALL;", "&SHALL_NOT;",
        "&SHOULD;", "&SHOULD_NOT;", "&RECOMMENDED;", "&NOT_RECOMMENDED;", "&MAY;", and
        "&OPTIONAL;" in this document are to be interpreted as described
        in <xref target="RFC2119" />.</t>

    <t>This document distinguishes the terms "client" and "user" in the following way:
       A "client" is an entity understanding and talking HTTP and the specified authentication protocol,
       usually computer software; a "user" is a (usually natural) person
       who wants to access data resources using a "client".</t>

    <!-- t>See <xref target="RFC4949" /> for security-related terms -->

    <t>The term "natural numbers" refers to the non-negative integers (including zero) throughout this document.</t>
    <t>This document treats both the input (domain) and the output (codomain) of hash functions to be octet strings.
<!--    the notation H(s) represents the octet-string output of hash function H applied to an octet string s.-->
    When a natural number output is required, the notation INT(H(s)) is used.</t>
  </section>

  <section title="Document Structure and Related Documents">
    <t>
       The entire document is organized as follows:

       <list style="symbols">
	 <t> <xref target="protocol-overview" /> presents an overview of the
         protocol design.</t>
         <t>Sections <xref target="syntax" format="counter" />
             to <xref target="srv-decision" format="counter" />
         define a general framework of the Mutual authentication protocol.
         This framework is independent of specific cryptographic primitives.</t>
	 <t> <xref target="algorithms" /> describes properties needed for cryptographic algorithms used with this protocol framework, and defines a few functions which will be shared among such cryptographic algorithms.</t>
	 <t> The sections after that contain general normative and informative information
             about the protocol.</t>
         <t> The appendices contain some information that may help developers to
             implement the protocol.</t>
	</list>
     </t>
     <t>In addition, there are two companion documents which are referred from/related to this specification:
       <list style="symbols">
		  <t><xref target="I-D.ietf-httpauth-mutual-algo" />: defines cryptographic primitives which can be used with this protocol framework.</t>
		  <t><xref target="I-D.ietf-httpauth-extension" />: defines small but useful extensions to the current HTTP authentication framework so that it can support application-level semantics of existing Web systems.</t>
       </list>
     </t>
  </section>
        
</section>

<section anchor="protocol-overview" title="Protocol Overview">

<t>
The protocol, as a whole, is designed as a natural extension to the
<xref target="RFC7230">HTTP protocol</xref> using a framework defined
in <xref target="RFC7235" />.  Internally, the server and the client
will first perform a cryptographic key exchange, using the secret
password as a "tweak" to the exchange.  The key exchange will only
succeed when the secrets used by the both peers are correctly related (i.e., generated from the same password).
Then, both peers will verify the authentication results by confirming
the sharing of the exchanged key.  This section provides a brief outline
of the protocol and the exchanged messages.
</t>

<section title="Messages Overview">
<t>The authentication protocol uses seven kinds of messages to perform mutual authentication.
These messages have specific names within this specification.

<list style="symbols">
	  <t> Authentication request messages: used by the servers to
	  request clients to start mutual authentication.
              <list style="symbols">
	      <t>&_401-INIT; message: a general message to start the authentication protocol.  It is also used as a message indicating an authentication failure.</t>
	      <t>&_401-STALE; message: a message indicating that client has to start a new key exchange.</t>
	      </list>
          </t>
	  <t>Authenticated key exchange messages: used by both peers to perform authentication and the sharing of a cryptographic secret.
              <list style="symbols">
	      <t>&_req-KEX-C1; message: a message sent from the client.</t>
	      <t>&_401-KEX-S1; message: a message sent from the server in response to a &_req-KEX-C1; message.</t>
	      </list>
	  </t>
	  <t>Authentication verification messages: used by both peers to verify the authentication results.
              <list style="symbols">
	      <t>&_req-VFY-C; message: a message used by the client, requesting the server authenticate and authorize the client.</t>
	      <t>&_200-VFY-S; message: a client-authentication successful response used by the server, which also simultaneously asserts to the client that the server is authentic.</t>
	      </list>
	  </t>
</list>
</t>

<t>
In addition to the above, either a request or a response without any HTTP headers 
related to this specification will be hereafter called a "normal request" or a "normal response", respectively.
</t>
</section>

<section title="Typical Flows of the Protocol">

<t>In typical cases, the client access to a resource protected by the Mutual authentication
scheme will use the following protocol sequence.</t>

<figure anchor="figure-flows-1" title="Typical communication flow for first access to resource">
<artwork><![CDATA[
       Client                                 Server
         |                                      |
         |  ---- (1) normal request --------->  |
     GET / HTTP/1.1                             |
         |                                      |
         |  <---------------- (2) 401-INIT ---  |
         |            401 Authentication Required
         |            WWW-Authenticate: Mutual realm="a realm"
         |                                      |
[user,   |                                      |
 pass]-->|                                      |
         |  ---- (3) req-KEX-C1 ------------->  |
     GET / HTTP/1.1                             |
     Authorization: Mutual user="john",         |--> [user DB]
                    kc1="...", ...              |<-- [user info]
         |                                      |
         |  <-------------- (4) 401-KEX-S1 ---  |
         |           401 Authentication Required
         |           WWW-Authenticate: Mutual sid=..., ks1="...", ...
         |                                      |
     [compute] (5) compute session secret   [compute]
         |                                      |
         |                                      |
         |  ---- (6) req-VFY-C -------------->  |
     GET / HTTP/1.1                             |--> [verify (6)]
     Authorization: Mutual sid=...,             |<-- OK
                    vkc="...", ...              |
         |                                      |
         |  <--------------- (7) 200-VFY-S ---  |
[verify  |           200 OK                     |
  (7)]<--|           Authentication-Info: Mutual vks="..."
         |                                      |
         v                                      v
]]></artwork>
</figure>

<t>
<list style="symbols">
   <t> As usual in general HTTP protocol designs, a client will at first request
       a resource without any authentication attempt (1).
       If the requested resource is protected by the Mutual authentication,
       the server will respond with a message requesting authentication (&_401-INIT;) (2).
   </t>
   <t> 
       The client processes the body of the message
       and waits for the user to input the user name and a password.
       If the user name and the password are available,
       the client will send a message with the authenticated key exchange (&_req-KEX-C1;)
       to start the authentication (3).
   </t>

   <t> If the server has received a &_req-KEX-C1; message,
       the server looks up the user's authentication information within its user database.
       Then the server creates a new session identifier (sid) that will be used
       to identify sets of the messages that follow it and
       responds back with a message containing a server-side
       authenticated key exchange value (&_401-KEX-S1;) (4).
   </t>

   <t>
       At this point (5), both peers calculate a shared "session secret" using the
       exchanged values in the key exchange messages.
       Only when both the server and the client have used secret credentials
       generated from the same password will the session secret values match.
       This session secret will be used for access authentication of
       every individual normal after this point.
   </t>

   <t> The client will send a request with a client-side authentication
       verification value (&_req-VFY-C;) (6),
       calculated from the client-generated session secret.
       The server will check the validity of the verification value using
       its own version of the session secret.</t>

   <t> If the authentication verification value from the client was correct, it means that the client
       definitely owns the credential based on the expected password
       (i.e., the client authentication succeeded).
       The server will respond with a successful message (&_200-VFY-S;) (7).
       Contrary to the usual one-way authentication
       (e.g., HTTP Basic authentication or <xref target="RFC1939">POP APOP authentication</xref>),
       this message also contains a server-side authentication verification value.
       <vspace blankLines="1" />
       When the client's verification value is incorrect (e.g.,&nbsp;because the user-supplied password was incorrect),
       the server will respond with the &_401-INIT; message (the same one as used in (2)) instead.
   </t>

   <t> The client &MUST; first check the validity of the server-side authentication verification value contained in the message (7).
       If the value was equal to the expected one, server authentication succeeded.
       <vspace blankLines="1" />
       If it is not the value expected, or if the message does not contain the authentication verification value, 
       it means that the mutual authentication has been broken for some unexpected reason.
       The client &MUST_NOT; process any body or header values contained in the HTTP response in this case.
       (Note: This case should not happen between a correctly implemented server and client
       without any active attacks.
       The possible cause of such a case might be either a man-in-the-middle
       attack or an incorrect implementation.)
   </t>
</list>
</t>

</section>
<section title="Alternative Flows">

<t>
   As shown above, the typical flow for a first authentication request requires three request-response pairs.
   To reduce the protocol overhead, the protocol enables several short-cut flows which require fewer messages.
<list style="symbols">  
<t>
(case A) If the client knows that
the resource is likely to require authentication, the client &MAY;
omit the first unauthenticated request (1) and immediately send a key exchange (&_req-KEX-C1; message).
This will reduce one round-trip of messages.
</t>
<t>
(case B) If both the client and the server previously shared a session secret
associated with a valid session identifier (sid), the client &MAY;
directly send a &_req-VFY-C; message using the existing session identifier and corresponding session secret.
This will further reduce one round-trip of messages.
<vspace blankLines="1" />
The server &MAY; have thrown out the corresponding session from the session table.
If so, the server will respond with a &_401-STALE; message, indicating a new key exchange is required.
The client &SHOULD; retry constructing a &_req-KEX-C1; message in this case.
</t>
</list>
</t>

<t>
<xref target="figure-flows-2" /> depicts the shortcut flows described above.
Under the appropriate settings and implementations, most of the requests to resources are expected to meet
both criteria, and thus only one round-trip of request/response will be required.
</t>
<figure anchor="figure-flows-2" title="Several alternative protocol flows">
<artwork><![CDATA[
    (A) omit first request
       (2 round trips)
   
     Client            Server 
     |                      |
     | --- req-KEX-C1 ----> |
     |                      |
     | <---- 401-KEX-S1 --- |
     |                      |
     | ---- req-VFY-C ----> |
     |                      |
     | <----- 200-VFY-S --- |
     |                      |
   
   
    (B) reusing session secret (re-authentication)

      (B-1) key available        (B-2) key expired
              (1 round trip)             (3 round trips)
                                                      
     Client            Server   Client              Server
     |                      |   |                        |
     | ---- req-VFY-C ----> |   | --- req-VFY-C -------> |
     |                      |   |                        |
     | <----- 200-VFY-S --- |   | <------- 401-STALE --- |
     |                      |   |                        |
                                | --- req-KEX-C1 ------> |
                                |                        |
                                | <------ 401-KEX-S1 --- |
                                |                        |
                                | --- req-VFY-C -------> |
                                |                        |
                                | <------- 200-VFY-S --- |
                                |                        |
]]></artwork>
</figure>


<t>
For more details, see Sections <xref target="cli-decision" format="counter"/>
and <xref target="srv-decision" format="counter" />.
</t>
</section>
</section>

<section anchor="syntax" title="Message Syntax">

<t>Throughout this specification, the syntax is denoted in the
   extended augmented BNF syntax defined in <xref
   target="RFC7230" />, and <xref
   target="RFC5234" />.  
   The following elements are quoted from <xref target="RFC5234" />, <xref
   target="RFC7230" /> and <xref target="RFC7235" />:
   DIGIT, ALPHA, SP, auth-scheme, quoted-string, auth-param, header-field, token, challenge, and credential.</t>

<t>
The Mutual authentication protocol uses three headers: &_WWW-Authenticate;
(usually in responses with status code 401), Authorization (in requests),
and &_Authentication-Info; (in responses other than 401 status).
These headers follow a common framework described in <xref target="RFC7235" /> and <xref target="RFC7615" />.
The detailed meanings for these headers are contained in <xref target="messages" />.
</t>

<t>
The framework in <xref target="RFC7235" /> defines the syntax for
the headers &_WWW-Authenticate; and Authorization as the syntax elements "challenge" and "credentials", respectively.
The "auth-scheme" contained in those headers &MUST; be "Mutual" throughout this protocol specification.
The syntax for "challenge" and "credentials" to be used with the "Mutual" auth-scheme &SHALL; be name-value pairs (#auth-param),
not the "b64token" defined in <xref target="RFC7235" />.
</t>

<t>
The Authentication-Info: header used in this protocol &SHALL; follow the syntax defined in 
<xref target="RFC7615" />.
</t>

<t>
In HTTP, the &_WWW-Authenticate; header may contain two or more challenges.
Client implementations &SHOULD; be aware of and be capable of handling those cases correctly.
</t>

<section title="Non-ASCII extended header parameters">
<t>
All of parameters contained in the above three headers, except the "realm" field,
&MAY; be extended to ISO 10646-1 values using the framework described in <xref target="RFC5987" />.
All servers and clients &MUST; be capable of receiving and sending values encoded in
<xref target="RFC5987" /> syntax.
</t>
<t>
If a value to be sent contains only ASCII characters, the field &MUST; be sent
using plain RFC 7235 syntax. The syntax as extended by RFC 5987 &MUST_NOT; be used in this case.
</t>
<t>
If a value (except the "realm" header) 
contains one or more non-ASCII characters, the parameter &SHOULD; be sent
using the syntax defined in Section 3.2 of <xref target="RFC5987" /> as "ext-parameter".
Such a parameter &MUST; have a charset value of "UTF-8", and the
language value &MUST; always be omitted (have an empty value).
The same parameter &MUST_NOT; be sent more than once, regardless of the used syntax.
</t>
<t>
For example, a parameter "user" with value "Renee of France" &SHOULD; be sent as
&lt; user="Renee of France" &gt;.  If the value is "Ren&lt;e&nbsp;acute&gt;e of France", it &SHOULD; be
sent as &lt; user*=UTF-8''Ren%C3%89e%20of%20France &gt; instead.
</t>
<t>
<xref target="RFC7235" /> requires the realm parameter to be
in its plain form (not as an extended "realm*" parameter), so
RFC 5987 syntax &MUST_NOT; be used for this parameter.
</t>

</section>

<section title="Values">

<t>
The parameter values contained in challenge/credentials &MUST; be
parsed strictly conforming to the HTTP semantics (especially
un-quoting of the string parameter values).  In this protocol, those
values are further categorized into the following value types: tokens
(bare-token and extensive-token), string, integer, hex-fixed-number,
and base64-fixed-number.
</t>

<t>
For clarity, implementations are &RECOMMENDED; to use the canonical
representations specified in the following subsections for sending
values.  Recipients &SHOULD; accept both quoted and unquoted
representations interchangeably as specified in HTTP.
</t>

<section title="Tokens">
<t>
For sustaining both security and extensibility at the same time, this protocol defines a 
stricter sub-syntax for the "token" to be used.
Extensive-token values &SHOULD; use the following syntax (after HTTP value parsing):
</t>

<figure anchor="figure-syntax" title="BNF syntax for token values">
<artwork type="abnf">
 bare-token       = 1*(DIGIT / ALPHA / "-" / "_")
 extension-token  = "-" bare-token 1*("." bare-token)
 extensive-token  = bare-token / extension-token
</artwork>
</figure>

<t>
The tokens (bare-token and extension-token) are case insensitive;
Senders &SHOULD; send these in lower case, and
receivers &MUST; accept both upper and lower cases.
When tokens are used as (partial) inputs to any hash or other mathematical functions,
they &MUST; always be used in lower case.
</t>

<t>
Extensive-tokens are used in this protocol where the set of acceptable tokens may
include non-standard extensions.  Any non-standard extension of this protocol &SHOULD; use the
extension-token with the format "-&lt;bare-token&gt;.&lt;domain&nbhy;name&gt;", where &lt;domain-name&gt; is
a valid (sub-)domain name on the Internet owned by the
party who defines the extension.
</t>

<t>Bare-tokens and extensive-tokens are also used for parameter names, in the unquoted form.
Requirements for using the extension-token for the parameter names are the same as the previous paragraph.</t>

<t>The canonical format for bare-tokens and extensive-tokens is the unquoted representation.</t>

</section>

<section anchor="syntax-string" title="Strings">

<t>
All character strings &MUST; be
encoded to octet strings using the <xref target="RFC3629">UTF-8 encoding</xref>
for the <xref target="ISO.10646-1.1993">ISO 10646-1 character set</xref>.
Such strings &MUST_NOT; contain any leading BOM characters (ZERO WIDTH NO-BREAK SPACE, U+FEFF or EF BB BF).
Both peers are &RECOMMENDED; to reject any invalid UTF-8 sequences that might cause
decoding ambiguities (e.g., containing &lt;&quot;&gt; in the
second or later bytes of the UTF-8 encoded characters).
</t>

<t>
If strings are representing a domain name or URI that contains
non-ASCII characters, the host parts &SHOULD; be encoded as it is used
in the HTTP protocol layer (e.g.,&nbsp;in a Host: header);
under current standards it will be the one defined in <xref target="RFC5890" />.
It &SHOULD; use lower-case ASCII characters.
</t>

<t>The canonical format for strings is quoted-string (as it may 
contain equal signs, plus signs and slashes), unless the parameter
containing the string value will use extended syntax defined in <xref target="RFC5987" />.
(An <xref target="RFC5987" /> extended parameter will have an unquoted encoded value,
 as defined therein.)
</t>

</section>

<section anchor="sec-numbers" title="Numbers">

<t>The following syntax definitions give a syntax for numeric values:</t>

<figure anchor="figure-syntax-numbers" title="BNF syntax for numbers">
<artwork type="abnf">
 integer          = "0" / (%x31-39 *DIGIT)      ; no leading zeros
 hex-fixed-number = 1*(2(DIGIT / %x41-46 / %x61-66))
 base64-fixed-number = 1*( ALPHA / DIGIT / "+" / "/" ) 0*2"="
</artwork>
</figure>

<t>
The syntax definition of the integers only allows representations
that do not contain leading zeros.
</t>

<t>
A number represented as a hex-fixed-number &MUST; include an even number of
hexadecimal digits (i.e., multiples of eight bits).
Those values are case-insensitive, and
&SHOULD; be sent in lower case. When these values are generated
from any cryptographic values, they &SHOULD; have their "natural length";
if these are generated from a hash function, these lengths &SHOULD;
correspond to the hash size; if these are representing elements of a
mathematical set (or group), its lengths &SHOULD; be the shortest for
representing all the elements in the set.  For example, the results of
the SHA-256 hash function will be represented by 64 digits, and any
elements in a 2048-bit prime field (modulo a 2048-bit integer) will be
represented by 512 digits, regardless of how much zeros appear
in front of such representations.
Session-identifiers and other non-cryptographically generated values
are represented in any (even) length determined by the side that
generates it first, and the same length &SHALL; be used throughout
all communications by both peers.
</t>

<t>
The numbers represented as base64-fixed-number &SHALL; be generated as
follows: first, the number is converted to a big-endian radix-256
binary representation as an octet string.  The length of the
representation is determined in the same way as mentioned above.
Then, the string is encoded using <xref target="RFC4648">the Base 64
encoding</xref> without any spaces and newlines.
Implementations decoding base64-fixed-number
&SHOULD; reject any input data with invalid characters,
excess/insufficient padding, or non-canonical pad bits (See Sections
3.1 to 3.5 of <xref target="RFC4648" />).
</t>

<t>The canonical format for integer and hex-fixed-number are unquoted tokens, and that for base64-fixed-number is quoted-string.</t>

</section>

</section>

</section>

<section title="Messages" anchor="messages">

<t>
In this section we define the seven kinds of messages used in the
authentication protocol along with the formats and requirements of the
headers for each message.
</t>

<t>
To determine in what circumstances each message is expected to be sent, see 
Sections <xref target="cli-decision" format="counter" /> and
<xref target="srv-decision" format="counter" />.</t>

<t>
In the descriptions below, the type of allowable values for each header
parameter is shown in parenthesis after each parameter name.  The
"algorithm-determined" type means that the acceptable value for the
parameter is one of the types defined in <xref target="syntax" />, and
is determined by the value of the "algorithm" parameter.
The parameters marked "mandatory" &SHALL; be contained in the message.
The parameters marked "non-mandatory" &MAY; either be contained or omitted in the message.
Each parameter &SHALL; appear in each header exactly once at most.
</t>

<t>
All credentials and challenges 
&MAY; contain any parameters not explicitly specified in the following sections.
Recipients that do not understand such parameters &MUST; silently ignore those.
However, all credentials and challenges &MUST; meet the following criteria:
<list style="symbols" hangIndent="3">
<t>
For responses, the parameters "reason", any "ks#" (where # stands for any
decimal integer), and "vks" are mutually exclusive; any challenge
&MUST_NOT; contain two or more parameters among them.  They &MUST_NOT;
contain any "kc#" or "vkc" parameters.
</t>
<t>
For requests, the parameters "kc#" (where # stands for any decimal
integer), and "vkc" are mutually exclusive and any challenge
&MUST_NOT; contain two or more parameters among them.  They &MUST_NOT;
contain any "ks#" or "vks" parameters.
</t>
</list>
</t>

<t>
Every message in this section contains a "version" field, to 
detect future, incompatible revisions of the protocol.
Implementations of the protocol described in this specification
&MUST; always send a token "&_Protocol_version_token;", and
recipients &MUST; reject messages that contain any other value
as a version, unless another specification defines a behavior
for that version.
[[Editorial Note: This token is updated on every draft revisions that affects the wire protocol.
It will be updated to "1" in the final published RFC.]]
</t>

<section title="401-INIT and 401-STALE" anchor="401-INIT">

<t>
Every &_401-INIT; or &_401-STALE; message &SHALL; be a valid HTTP 401-status (Authentication Required) message
(or other 4XX status if sensible) containing one and only one (hereafter not explicitly noted)
"&_WWW-Authenticate;" header containing a "reason" parameter in the challenge.
The challenge &SHALL; contain all of the parameters marked "mandatory" below, and &MAY; contain those marked "non-mandatory".

<list style="hanging" hangIndent="15">

<t hangText="version:">(mandatory extensive-token) should be the token "&_Protocol_version_token;".</t>
<t hangText="algorithm:">(mandatory extensive-token) specifies the authentication algorithm to be used.
	    The value &MUST; be one of the tokens specified in <xref target="I-D.ietf-httpauth-mutual-algo" /> or another supplemental specification.
 </t>
<t hangText="validation:">(mandatory extensive-token) specifies the method of host validation.
	    The value &MUST; be one of the tokens described in <xref target="validation" />
	    or the tokens specified in another supplemental specification.
 </t>
<t hangText="auth-scope:">(non-mandatory string) specifies the authentication scope,
            the set of hosts for which the authentication credentials are valid.
            It &MUST; be one of the strings
            described in <xref target="authrealm" />.
            If the value is omitted, it is assumed to be the "single-server" type domain
            in <xref target="authrealm" />.
</t>
<t hangText="realm:">(mandatory string) is a string representing the name of the authentication
	    realm inside the authentication scope.  As specified in <xref target="RFC7235" />,
            this value &MUST; always be sent in the quoted-string form,
            and an <xref target="RFC5987" /> encoding &MUST_NOT; be used.<vspace blankLines="0" />
            The realm value sent from the server &SHOULD; be an ASCII string.
            Clients &MAY; treat any non-ASCII value received in this field
            as a binary blob, an NFC-normalized UTF-8 string, or an error.
</t>
<t hangText="pwd-hash:">(non-mandatory extensive-token) specifies the hash algorithm
	    (hereafter referred to as ph) used for additionally hashing the password.
	    The valid tokens are

	    <list style="symbols" hangIndent="3">
	     <t> none: ph(p) = p</t>
	     <t> md5: ph(p) = MD5(p)</t>
<!--	     <t> digest-md5: ph(p) = MD5(username | ":" | realm | ":" | p),
                the same value as MD5(A1) for "MD5" algorithm in <xref target="RFC2617" />.</t> -->
	     <t> sha1: ph(p) = SHA1(p)</t>
	    </list>
	    If omitted, the value "none" is assumed.
	    The use of "none" is desirable.  See <xref target="sec-usage" /> for more usage considerations.
 </t>
<t hangText="reason:">(mandatory extensive-token) &SHALL; be an extensive-token that describes
the possible reason of the failed authentication/authorization.  Both servers and clients
&SHALL; understand and support the following three tokens:
	    <list style="symbols" hangIndent="3">
		<t> initial: authentication was not tried because there was no &_Authorization; header in the corresponding request.</t>
		<t> stale-session: the provided sid in the request was either unknown to or expired in the server.</t>
		<t> auth-failed: authentication trial was failed for some reason, possibly with a bad authentication credential.</t>
	    </list>
            Implementations &MAY; support the following tokens or any extensive-tokens defined outside this specification.
            If clients receive any unknown tokens, they &SHOULD; treat these as if they were "auth-failed" or "initial".
	    <list style="symbols" hangIndent="3">
		<t> reauth-needed: the server-side application requires a new authentication trial, regardless of the current status.</t>
		<t> invalid-parameters: the server did not attempt authentication because some parameters were not acceptable.</t>
		<t> internal-error: the server did not attempt authentication because there are some troubles on the server-side.</t>

		<t> user-unknown: this is a special case of auth-failed, suggesting that the provided user name is invalid.  The use of this parameter is &NOT_RECOMMENDED; due to security implications, except for special-purpose applications where it makes sense.</t>
		<t> invalid-credential: ditto, suggesting that the provided user name was valid but authentication still failed.  The use of this parameter is &NOT_RECOMMENDED; for security reasons.</t>
		<t> authz-failed: authentication was successful, but access to the specified resource is not authorized to the specific authenticated user.  (It might be used along with either a 401 or 403 status to indicate that the authentication result is one of the existing reasons for the failed authorization.)</t>
	    </list>
</t>
</list>
</t>

<t>
The algorithm specified in this header will determine the types (among those defined in <xref target="syntax" />) and the values for &_K_c1;, &_K_s1;, &_VK_c; and &_VK_s;.
</t>

<t>
Among these messages, those with the reason parameter of value "stale-session" will be
called "401-STALE" messages hereafter, because these have a special meaning in the protocol flow.
Messages with any other reason parameters will be called "401-INIT" messages.
</t>

</section>

<section title="req-KEX-C1">

<t>
Every &_req-KEX-C1; message &SHALL; be a valid HTTP request message containing an
"Authorization" header with a credential containing a "kc1" parameter.
</t>

<t>
The credential &SHALL; contain the parameters with the following names:
</t>

<t>
<list style="hanging" hangIndent="15">

<t hangText="version:">(mandatory, extensive-token) should be the token "&_Protocol_version_token;".
 </t>
<t hangText="algorithm, validation, auth-scope, realm:">&MUST; be the same values as received from the server.
 </t>
<t hangText="user:">(mandatory, string) is the UTF-8 encoded name of the user.  The string &SHOULD; be prepared according to the method presented in <xref target="sec-normalize" />.
 </t>
<t hangText="kc1:">(mandatory, algorithm-determined) is the client-side key exchange value &_K_c1;, which is specified by the algorithm that is used.
</t>
</list>
</t>

</section>

<section title="401-KEX-S1">

<t>
Every &_401-KEX-S1; message &SHALL; be a valid HTTP 401-status (Authentication Required) response message
containing a "&_WWW-Authenticate;" header with a challenge containing a "ks1" parameter.
</t>

<t>
The challenge &SHALL; contain the parameters with the following names:
</t>

<t>
<list style="hanging" hangIndent="15">
<t hangText="version:">(mandatory, extensive-token) should be the token "&_Protocol_version_token;".
 </t>
<t hangText="algorithm, validation, auth-scope, realm:">&MUST; be the same values as received from the client.
</t>
<t hangText="sid:">(mandatory, hex-fixed-number) &MUST; be a session identifier, which is a random
	    integer.  The sid &SHOULD; have uniqueness of at least 80 bits or
	    the square of the maximum estimated transactions
	    concurrently available in the session table, whichever is
	    larger.  See <xref target="session" /> for more details.
 </t>
<t hangText="ks1:">(mandatory, algorithm-determined) is the server-side key exchange value &_K_s1;, which is specified by the algorithm.

 </t>
<t hangText="nc-max:">(mandatory, integer) is the maximum value of nonce numbers that the server accepts.
 </t>
<t hangText="nc-window:">(mandatory, integer) the number of available nonce number slots that the server will accept.
	    The value of the &_nc-window; parameter is &RECOMMENDED; to be 128 or more.
	    <!-- HTTP/2.0 recommends at least 100 concurrent streams to exist at once. -->
 </t>
<t hangText="time:">(mandatory, integer) represents the suggested time (in
	    seconds) that the client can reuse the session represented by the sid.
            It is &RECOMMENDED; to be at
	    least 60. The value of this parameter is not directly linked to the
	    duration that the server keeps track for the session represented by the sid.
 </t>
<t hangText="path:">(non-mandatory, string) specifies which path in the URI space the same
	    authentication is expected to be applied.  The value is a space-separated list of URIs, in the same format
	    as it was specified in domain parameter <xref target="RFC7616" />
	    for Digest authentications.  All path elements contained in the parameter &MUST; be
            inside the specified auth-scope; if not, clients &SHOULD; ignore such elements.
	    For better performance, recognition of this parameter by clients is important.
</t>
</list>
</t>

</section>

<section title="req-VFY-C">

<t>
Every &_req-VFY-C; message &SHALL; be a valid HTTP request message containing an
"&_Authorization;" header with a credential containing a "vkc" parameter.
</t>

<t>
The parameters contained in the header are as follows:

<list style="hanging" hangIndent="15">
<t hangText="version:">(mandatory, extensive-token) should be the token "&_Protocol_version_token;".
 </t>
<t hangText="algorithm, validation, auth-scope, realm:">&MUST; be the same values as received from the server for the session.
 </t>
<t hangText="sid:">(mandatory, hex-fixed-number) &MUST; be one of the sid values that was received from the server for the same authentication realm.
 </t>
<t hangText="nc:">(mandatory, integer) is a nonce request number that is unique among the requests sharing the same sid.  The values of the nonce numbers &SHOULD; satisfy the properties outlined in <xref target="session" />.
</t>
<t hangText="vkc:">(mandatory, algorithm-determined) is the client-side authentication verification value &_VK_c;, which is specified by the algorithm.
</t>
</list>
</t>

</section>

<section title="200-VFY-S">

<t>
Every &_200-VFY-S; message &SHALL; be a valid HTTP message
that does not have a 401 (Authentication Required) status code and
&SHALL; contain an "&_Authentication-Info;" header with a "vks" parameter.
</t>

<t>
The parameters contained in the header are as follows:
</t>

<t>
<list style="hanging" hangIndent="15">

<t hangText="version:">(mandatory, extensive-token) should be the token "&_Protocol_version_token;".
 </t>
<t hangText="sid:">(mandatory, hex-fixed-number) &MUST; be the value received from the client.
 </t>
<t hangText="vks:">(mandatory, algorithm-determined) is the server-side authentication verification value &_VK_s;, which is specified by the algorithm.
 </t>
</list>
</t>

<t>
The header &MUST; be sent
before the content body: it &MUST_NOT; be sent in the trailer of
a chunked-encoded response.
If a "100 Continue" response is sent from the server,
the &_Authentication-Info; header &SHOULD; be included in that response,
instead of the final response.  
</t>

</section>

</section>

<section title="Authentication Realms" anchor="authrealm">

<t>
In this protocol, an "authentication realm" is defined as a set of resources (URIs)
for which the same set of user names and passwords is valid.
If the server requests authentication for an authentication realm 
that the client is already authenticated for, the client will automatically
perform the authentication using the already-known credentials.
However, for different authentication realms, clients &MUST_NOT; 
automatically reuse user names and passwords for another realm.
</t>

<t>
Just like in the Basic and Digest access authentication protocols, the Mutual
authentication protocol supports multiple, separate protection spaces
to be set up inside each host.  Furthermore, the protocol allows
a single authentication realm to span over several hosts within the same
Internet domain.
</t>

<t>
Each authentication realm is defined and distinguished by the triple of an "authentication algorithm",
an "authentication scope", and a "realm" parameter.  However, server operators are
&NOT_RECOMMENDED; to use the same pair of an authentication scope and a
realm with different authentication algorithms.
</t>

<t>
The realm parameter is a string as defined in <xref target="messages" />.
Authentication scopes are described in the remainder of this section.
</t>

<t>
An authentication scope specifies the range of hosts that the authentication realm spans over.
In this protocol, it &MUST; be one of the following kinds of strings.

<list style="symbols" hangIndent="3">
  <t>Single-server type: A string in the format "&lt;scheme&gt;://&lt;host&gt;" or
     "&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;",
     where &lt;scheme&gt;, &lt;host&gt;, and
     &lt;port&gt; are the corresponding URI parts of the request URI.
     If the default port (i.e., 80 for http and 443 for https) is
     used for the underlying HTTP communications, the port part
     &MUST; be omitted, regardless of whether it was
     present in the request-URI.
     In all other cases, the port part &MUST; be present, and
     it &MUST_NOT; contain leading zeros.
     Use this format when authentication is only valid for a specific protocol
     (such as https).
     This format is equivalent to the ASCII
     serialization of a Web Origin, presented in Section 6.2 of <xref
     target="RFC6454" />.
  </t>
  <t>Single-host type: The "host" part of the requested URI. This is the default value.
     Authentication realms within this kind of authentication scope will span over
     several protocols (e.g., http and https) and ports, but not over different hosts.
  </t>
  <t>Wildcard-domain type: 
     A string in the format "*.&lt;domain&nbhy;postfix&gt;", where &lt;domain&nbhy;postfix&gt; is
     either the host part of the requested URI or any domain in which
     the requested host is included (this means that the specification "*.example.com" is
     valid for all of hosts "www.example.com", "web.example.com", "www.sales.example.com" and "example.com").
     The domain-postfix sent by the servers &MUST; be equal to or included in a valid Internet domain assigned to
     a specific organization; if clients know, by some means such as a blacklist for <xref target="RFC6265">HTTP cookies</xref>,
     that the specified domain is not to be assigned to any specific organization
     (e.g., "*.com" or "*.jp"), clients are &RECOMMENDED; to reject the authentication request.
  </t>
</list>
</t>

<t>
In the above specifications, every "scheme", "host", and "domain" &MUST; be in lower case,
and any internationalized domain names beyond the ASCII character set &SHALL; be
represented in the way they are
sent in the underlying HTTP protocol, represented in lower case characters,
i.e.,&nbsp;these domain names &SHALL; be in the form of LDH labels in <xref target="RFC5890">IDNA</xref>.
A "port" &MUST; be given in the shortest, unsigned, decimal number notation.
Not obeying these requirements will cause failure of valid authentication attempts.
</t>

<section title="Resolving Ambiguities">
<t>
In the above definitions of authentication scopes, several scopes may overlap each other.
If a client has already been authenticated to several realms applicable to the same server,
the client may have a multiple lists of the "path" parameters received with the "&_401-KEX-S1;" message (see <xref target="messages" />).
If these path lists have any overlap, a single URI may belong to multiple possible candidate 
 of realms to be authenticated to.
In such cases, clients faces an ambiguity in deciding which credentials to 
send for a new request (in steps 3 and 4 of the decision procedure presented in <xref target="cli-decision" />).
</t>

<t>
In such cases, a client &MAY; send request which belong to any of these candidate realms
freely, or it &MAY; simply send an unauthenticated request and see for which realm
the server requests an authentication.
Server operators are &RECOMMENDED; to provide properly-configured "path" parameters
(more precisely, disjoint path sets for each realms) for clients so that
such ambiguities will not occur.
</t>

<t>
The following procedure is one possible tactic for resolving ambiguity in such cases.
<list style="symbols" hangIndent="3">
  <t> If the client has previously sent a request to the same URI, and
      if it remembers the authentication realm requested by the &_401-INIT; message at that time,
      use that realm.
  </t>
  <t>
      In other cases, use one of the authentication realms representing
      the most-specific authentication scopes.
      The list of possible domain specifications shown above is
      given from most specific to least specific.
      <vspace blankLines="1" />
      If there are several choices with different wildcard-domain specifications,
      the one that has the longest domain-postfix has priority over ones with shorter domain-postfixes.
  </t>
  <t>
      If there are realms with the same authentication scope,
      there is no defined priority; the client &MAY; choose any one of the possible choices.
  </t>
</list>
</t>
</section>

</section>

<section title="Session Management" anchor="session">

<t>
In the Mutual authentication protocol, a session represented by an sid is set up
using four messages (first request, &_401-INIT;, &_req-KEX-C1; and &_401-KEX-S1;),
after which a "session secret" (z) associated with the session is established.
After mutually establishing a session secret, this session, along with the secret, can be used
for one or more requests for resources protected by the same realm on the
same server.  Note that session management is only an inside detail of the
protocol and usually not visible to normal users.  If a session expires,
the client and server &SHOULD; automatically re-establish another session
without informing the user.
</t>

<t>
Sessions and session identifiers are local to each server (defined by
scheme, host, and port), even if an authentication scope covers multiple servers;
clients &MUST; establish separate sessions for each port of a host to be
accessed.  Furthermore, sessions and identifiers are also local to
each authentication realm, even if these are provided by the same
server.  The same session identifiers provided either from different
servers or for different realms &MUST; be treated as independent
or each other.
</t>

<t>
The server &SHOULD; accept at least one &_req-VFY-C; request for each session,
if the request reaches the server in a time window specified
by the timeout parameter in the &_401-KEX-S1; message, and there are
no emergent reasons (such as flooding attacks) to forget the session.
After that, the server &MAY; discard any session at any time and &MAY; send
&_401-STALE; messages for any further &_req-VFY-C; requests received for that session.
</t>

<t>
The client &MAY; send two or more requests using a single session
specified by the sid.  However, for all such requests, each value of the
nonce number (in the nc parameter) &MUST; satisfy the following conditions:

<list style="symbols" hangIndent="3">
  <t>It is a natural number.</t>
  <t>The same nonce number was not sent within the same session.</t>
  <t>It is not larger than the nc-max value that was
     sent from the server in the session represented by the sid.</t>
  <t>It is larger than (largest-nc &minus; nc-window),
     where largest-nc is the largest value of nc
     which was previously sent in the session,
     and nc-window is the value of the nc-window parameter
     that was received from the server for the session.</t>
</list>
</t>

<t>
The last condition allows servers to reject any nonce numbers that are
"significantly" smaller than the "current" value (defined by the value
of nc-window) of the nonce number used in the session involved.  In other
words, servers &MAY; treat such nonce numbers as "already received".
This restriction enables servers to implement duplicate nonce detection
in a constant amount of memory for each session.
</t>

<t>
Servers &MUST; check for duplication of the received nonce numbers, and if any
duplication is detected, the server &MUST; discard the session and respond
with a &_401-STALE; message, as outlined in <xref target="srv-decision" />.
The server &MAY; also reject other invalid
nonce numbers (such as ones above the nc-max limit) by sending a &_401-STALE; message.
</t>

<t>
For example, assume the nc-window value of the current session is
128, nc-max is 400, and that the client has already used the
following nonce numbers: {1-120, 122, 124, 130-238, 255-360,
363-372}.  Then the nonce number that can be used for the next request is
one of the following set: {245-254, 361, 362, 373-400}.  The values {0, 121,
123, 125-129, 239-244} &MAY; be rejected by the server because they are not above the
current "window limit" (244 = 372 - 128).
</t>

<t>
Typically, clients can ensure the above property by using a 
monotonically-increasing integer counter that counts from zero up to the value of nc-max.
</t>

<t>
The values of the nonce numbers and any nonce-related values &MUST; always be
treated as natural numbers within an infinite range.
Implementations which uses fixed-width integer representations,
fixed-precision floating-point numbers, or similar representations
&SHOULD_NOT; reject any larger values which overflow such representative limits,
and &MUST_NOT; silently truncate them using any modulus-like rounding operation (e.g., by mod 2^32).
Instead, the whole protocol is carefully designed
so that recipients &MAY; replace any such overflowing values
(e.g. 2^80) with some reasonably-large maximum representative integer (e.g., 2^31 - 1 or others).
</t>

</section>

<section title="Host Validation Methods" anchor="validation">

<t>
The "validation method" specifies a method to "relate" (or "bind") the mutual
authentication processed by this protocol with other authentications
already performed in the underlying layers and to prevent man-in-the-middle attacks.
It determines the value vh that is an input to the authentication protocols.
</t>

<t>
When HTTPS or other possible secure transport is used,
this corresponds to the idea of "channel binding" described
in <xref target="RFC5929" />.  
Even when HTTP is used, similar, but somewhat limited,
"binding" is performed to prevent a malicious server from trying
to authenticate itself to another server
as a valid user by forwarding the received credentials.
</t>

<t>
The valid tokens for the validation parameter and corresponding values of vh
are as follows:
</t>

<t>
<list style="hanging" hangIndent="15">
 <t hangText="host:"> host-name validation: The value vh will be the ASCII string in the
       following format: "&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;",
       where &lt;scheme&gt;, &lt;host&gt;, and &lt;port&gt; 
       are the URI components corresponding to the currently accessing resource.
       The scheme and host are in lower case, and the port is in a shortest
       decimal representation.  Even if the request-URI does not have a
       port part, v will include the default port number.</t>
 <t hangText="tls-server-end-point:"> 
   TLS endpoint (certificate) validation: The value vh will be the octet string of
   the hash value of the server's public key certificate used in the underlying
   <xref target="RFC5246">TLS</xref> connection, processed
   as specified in Section 4.1 of <xref target="RFC5929" />.
   <vspace blankLines="1" />
 </t>
 <t hangText="tls-unique:"> TLS shared-key validation: The value vh will be the 
 channel binding material derived from the Finished messages,
 as defined in Section 3.1 of <xref target="RFC5929" />.
 (Note: see <xref target="sec-security-tls-unique" /> for some security notices when using this validation method.)
</t>
</list>
</t>

<t>
If HTTP is used on a non-encrypted channel (TCP and SCTP, for example), the validation type
&MUST; be "host".  If <xref target="RFC2818">HTTP/TLS</xref> (HTTPS) is
used with a server certificate, the validation type &MUST; be "&_tls-server-end-point;".
If HTTP/TLS is used with an anonymous
Diffie-Hellman key exchange, the validation type &MUST; be
"&_tls-unique;" (see the note below).
</t>

<t>
Implementations supporting Mutual authentication over HTTPS &SHOULD; support
the "&_tls-server-end-point;" validation.
Support for "&_tls-unique;" validation is &OPTIONAL; for both servers and clients.
</t>

<t>
If the validation type "&_tls-server-end-point;" is used, the server certificate
provided in the TLS connection &MUST; be verified at least to make sure that the
server actually owns the corresponding private key.
(Note: this verification is automatic in some RSA-based key exchanges but
NOT automatic in Diffie-Hellman-based key exchanges with separate exchange for
server verification.)
</t>

<t>
Clients &MUST; validate this parameter upon receipt of &_401-INIT; messages.
</t>

<t>
Note: The protocol defines two variants of validation on the TLS connections.
The "&_tls-unique;" method is more secure.  However, there are some situations
where &_tls-server-end-point; is more preferable.
<list style="symbols">
<t>When TLS accelerating proxies are used, it is
difficult for the authenticating server to acquire the TLS key
information that is used between the client and the proxy.
This is not the case for client-side "tunneling" proxies using
the HTTP CONNECT method.
</t>
<t>When a black-box implementation of the TLS protocol is used on
either peer.
</t>
</list>
</t>

<section title="Applicability notes">

<t>
When the client is a Web browser with any scripting capabilities,
the underlying TLS channel used with HTTP/TLS &MUST; provide server identity verification.
This means (1) anonymous Diffie-Hellman key exchange cipher suites &MUST_NOT; be used,
and (2) verification of the server certificate provided by the server &MUST; be performed.
</t>

<t>
For other systems, when the underlying TLS channel used with HTTP/TLS does
not perform server identity verification, the client &SHOULD; ensure
that all the responses are validated using the Mutual authentication
protocol, regardless of the existence of &_401-INIT; responses.
</t>
</section>

<section title="Notes on tls-unique" anchor="sec-security-tls-unique">
  <t>
    As described in the interoperability note in the above channel binding specification,
    the tls-unique verification value will be changed by possible TLS renegotiation,
    causing an interoperability problem.  TLS re-negotiations are used in several
    HTTPS server implementations for enforcing some security properties
    (such as cryptographic strength) for some specific responses.
  </t>
  <t>
    If an implementation supports the "tls-unique" verification method,
    the following caution &SHOULD; be taken:
    <list style="symbols" hangIndent="3">
      <t>Both peers must be aware that the vh values used for vkc (in &_req-VFY-C;)
      and for vks (in &_200-VFY-S;) may be different.  These values &MUST; be
      retrieved from underlying TLS libraries each time they are used.</t>
      <t>After calculating the values vh and &_vkc; to send a &_req-VFY-C; request,
      Clients &SHOULD_NOT; initiate TLS renegotiation until the end of the
      corresponding response header is received.  An exception is that
      clients can and &SHOULD; perform TLS re-negotiation as a response to
      the server's request for TLS renegotiation, before
      receipt of the beginning of the response header.</t>
    </list>
  </t>
  <t>
    Also, implementers &MUST; take care of session resumption attacks regarding
    tls-unique channel binding mechanisms and master secrets.
    As a mitigation, a TLS extension defined in <xref target="RFC7627" />
    &SHOULD; be used when tls-unique host verification is to be used.
  </t>
</section>

</section>

<section title="Authentication Extensions" anchor="auth-extensions">

<t>
Interactive clients (e.g., Web browsers) supporting this protocol
are &RECOMMENDED; to support non-mandatory authentication and
the &_Authentication-Control; header defined in <xref target="I-D.ietf-httpauth-extension" />,
except for the "auth-style" parameter.
This specification also proposes (however, does not mandate) the default "auth-style" be "non-modal".
Web applications &SHOULD; however consider the security impacts of the behaviors of clients 
that do not support these headers.
</t>

<t>
Authentication-initializing messages with the
&_Optional-WWW-Authenticate; header are used only where the &_401-INIT;
response is valid.  It will not replace other 401-type
messages such as &_401-STALE; and &_401-KEX-S1;.
</t>

</section>

<section anchor="sec-normalize" title="String Preparation">
<t>
It is important for interoperability that user names and passwords
used in this protocol are binary-comparable regardless of the user's
input methods and/or environments.  To ensure this, the following
preparation &SHOULD; be performed:
<list style="symbols">
<t>
User names received from users &SHOULD; be prepared using the
"UsernameCasePreserved" profile defined in Section 3.3 of
<xref target="RFC7613" />.
</t>
<t>
Passwords received from users &SHOULD; be prepared using the
"OpaqueString" profile defined in Section 4.2 of
<xref target="RFC7613" />.
</t>
</list>
</t>

<t>
In both cases, it is the sender's duty to correctly prepare the character strings.
If any non-normalized character string is received from the other peer of the communication,
recipients &MAY; either use it as a bare UTF-8 string without any preparation,
perform any appropriate preparations (which may cause authentication failure),
or reject any ill-prepared inputs from the sender and respond as a communication error.
</t>

<t>
Server applications &SHOULD; also prepare user names and passwords
accordingly upon registration of user credentials.
</t>

<t>
In addition, binary-based "interfaces" of implementations &MAY; require
and assume that the string is already prepared accordingly; 
when a string is already stored as a binary Unicode string form,
implementations &MAY; omit preparation and Unicode normalization (performing
UTF-8 encoding only) before using it.
When a string is already stored as an octet blob, implementations &MAY;
send it as is.
</t>
</section>

<section title="Decision Procedure for Clients" anchor="cli-decision">

<section title="General Principles and Requirements">
<t>
To securely implement the protocol, the client must be careful
about accepting the authenticated responses from the server.  This
also holds true for the reception of "normal responses" (responses
which do not contain Mutual authentication-related headers) from HTTP servers.
</t>

<t>
As usual in the HTTP authentication, a single user-level request may result in
exchange of two-or-more HTTP requests and responses in sequence.
The following normative rules &MUST; be followed by the clients implementing this protocol:
<list style="symbols">
<t>
Any kinds of "normal responses" &MUST; only be accepted for the very first request in the sequence.
Any "normal responses" returned for the second or later requests in the sequence &SHALL; be considered invalid.
</t>
<t>
In the same principle, any responses which refer to or request
changing to an authentication realm different from the client's
request &MUST; only be accepted for the very first request in the
sequence.  Any kind of responses referring to different realms
which are returned for the second or later requests in the sequence
&SHALL; be considered invalid.
</t>
<t>
A &_req-KEX-C1; message &MAY; be sent either as a initial request or
as a response to &_401-INIT; or &_401-STALE;.  However, it
&SHOULD_NOT; be sent more than once in the sequence for a single
authentication realm, to avoid infinite loops of messages.
A &_401-KEX-S1; response &MUST; be accepted only when the corresponding
request is &_req-KEX-C1;.
</t>
<t>
A &_req-VFY-C; message &MAY; be sent if there is a valid session key
shared between the client and the server, established by &_req-KEX-C1;
and &_401-KEX-S1;.  If any response with 401 status is returned for
such a message, the corresponding session key &SHOULD; be discarded as
unusable.<vspace blankLines="0" />Especially, upon the reception of
a &_401-STALE; response, the client &SHOULD; try establishing a new
session by sending &_req-KEX-C1;, but only once within the
request/response sequence.
</t>
<t>
A &_200-VFY-S; message &MUST; be accepted only as a response to
&_req-VFY-C; and nothing else.  The &_VK_s; values of such response
messages &MUST; always be checked against the correct value, and if it
is incorrect, the whole response &SHOULD; be considered invalid.
</t>
</list>
</t>

<t>
The final status of the client request following the message exchange sequence
shall be determined as follows:
<list style="symbols">
<t>AUTH-SUCCEED: A &_200-VFY-S; message with the correct &_VK_s; value was
returned in response to the &_req-VFY-C; request in the sequence.</t>
<t>AUTH-REQUIRED: Two cases exists.
<list style="symbols">
<t>
  A &_401-INIT; message was returned from the server, and
  the client does not know how to authenticate to the given authentication realm.</t>
<t>
  A &_401-INIT; response was returned for &_req-VFY-C; (or &_req-KEX-C1;),
  which means the user-supplied authentication credentials were not accepted.</t>
</list>
</t>
<t>
 UNAUTHENTICATED: a normal response is returned for an initial request of any kind
 in the sequence.
</t>
</list>
</t>

<t>
Any kind of response (including a normal response) other than those
explicitly allowed in the above rules &SHOULD; be interpreted as a fatal
communication error.  In such cases, the clients &MUST_NOT; process
any data (the response body and other content-related headers) sent from
the server.  However, to handle exceptional error cases, clients &MAY;
accept a message without an &_Authentication-Info; header, if it has a
Server-Error (5xx) status code.  In such cases, they &SHOULD; be careful about
processing the body of the content (ignoring it is still &RECOMMENDED;,
as it may possibly be forged by intermediate attackers),
and the client will be in the "UNAUTHENTICATED" status then.
</t>

<t>
If a request is a sub-request for a resource included in another resource
(e.g., embedded images, style sheets, frames etc.),
clients &MAY; treat an AUTH-REQUESTED status as the same as
an UNAUTHENTICATED status.  In other words, the client &MAY; ignore
server's request to start authentication with new credentials via sub-requests.
</t>

</section>

<section title="State machine for the client (informative)" >

<t>
The following state machine describes the possible request-response
sequences derived from the above normative rules.
If implementers are not quite sure on the security consequences of the above
rules, it is strongly advised to follow the decision procedure below.
In particular, clients &SHOULD_NOT; accept "normal responses" unless explicitly allowed in the rules.
The labels on the steps are for informational purposes only.  Action entries within each step are
checked in top-to-bottom order, and the first clause satisfied is to be followed.

<list style="hanging" hangIndent="4">
  <t hangText="Step 1 (step_new_request):"><vspace blankLines="0" />
  If the client software needs to access a new Web resource, check
  whether the resource is expected to be inside some authentication realm for which the user
  has already been authenticated by the Mutual authentication scheme.
  If yes, go to Step 2. Otherwise, go to Step 5.
  </t>

  <t hangText="Step 2:"><vspace blankLines="0" />
  Check whether there is an available sid for the expected authentication realm.
  If there is one, go to Step 3. Otherwise, go to Step 4.
  </t>

  <t hangText="Step 3 (step_send_vfy_1):"><vspace blankLines="0" />
  Send a &_req-VFY-C; request.
  <list style="symbols" hangIndent="3">
   <t>If you receive a &_401-INIT; message with a different authentication realm than expected,
    go to Step 6.</t>
   <t>If a &_401-STALE; message is received, go to Step 9.</t>
   <t>If a &_401-INIT; message is received, go to Step 13.</t>
   <t>If a &_200-VFY-S; message is received, go to Step 14.</t>
   <t>If a normal response is received, go to Step 11.</t>
  </list>
  </t>

  <t hangText="Step 4 (step_send_kex1_1):"><vspace blankLines="0" />
  Send a &_req-KEX-C1; request.
  <list style="symbols" hangIndent="3">
   <t>If a &_401-INIT; message is received with a different authentication realm than expected,
    go to Step 6.</t>
   <t>If a &_401-KEX-S1; message is received, go to Step 10.</t>
   <t>If a &_401-INIT; message is received with the same authentication realm, go to Step 13 (see Note 1).</t>
   <t>If a normal response is received, go to Step 11.</t>
  </list>
  </t>

  <t hangText="Step 5 (step_send_normal_1):"><vspace blankLines="0" />
  Send a request without any Mutual authentication headers.
  <list style="symbols" hangIndent="3">
   <t>If a &_401-INIT; message is received, go to Step 6.</t>
   <t>If a normal response is received, go to Step 11.</t>
  </list>
  </t>

  <t hangText="Step 6 (step_rcvd_init):"><vspace blankLines="0" />
  Check whether the user's password for the requested authentication realm is known.
  If yes, go to Step 7.  Otherwise, go to Step 12.</t>

  <t hangText="Step 7:"><vspace blankLines="0" />
  Check whether there is an available sid for the expected authentication realm.
  If there is one, go to Step 8. Otherwise, go to Step 9.
  </t>

  <t hangText="Step 8 (step_send_vfy):"><vspace blankLines="0" />
  Send a &_req-VFY-C; request.
  <list style="symbols" hangIndent="3">
   <t>If a &_401-STALE; message is received, go to Step 9.</t>
   <t>If a &_401-INIT; message is received, go to Step 13.</t>
   <t>If a &_200-VFY-S; message is received, go to Step 14.</t>
  </list>
  </t>

  <t hangText="Step 9 (step_send_kex1):"><vspace blankLines="0" />
  Send a &_req-KEX-C1; request.
  <list style="symbols" hangIndent="3">
   <t>If a &_401-KEX-S1; message is received, go to Step 10.</t>
   <t>If a &_401-INIT; message is received, go to Step 13 (See Note 1).</t>
  </list>
  </t>

  <t hangText="Step 10 (step_rcvd_kex1):"><vspace blankLines="0" />
  Send a &_req-VFY-C; request.
  <list style="symbols" hangIndent="3">
   <t>If a &_401-INIT; message is received, go to Step 13.</t>
   <t>If a &_200-VFY-S; message is received, go to Step 14.</t>
  </list>
  </t>

  <t hangText="Step 11 (step_rcvd_normal):"><vspace blankLines="0" />
  The requested resource is out of the authenticated area.
  The client will be in the "UNAUTHENTICATED" status.  If the response contains
  a request for authentications other than Mutual, it &MAY; be handled normally.
  </t>

  <t hangText="Step 12 (step_rcvd_init_unknown):"><vspace blankLines="0" />
  The requested resource requires Mutual
  authentication, and the user is not yet authenticated.  The client
  will be in the "AUTH-REQUESTED" status, and is &RECOMMENDED; to process the
  content sent from the server, and to ask the user for a user name and a password.
  When those are supplied from the user, proceed to Step 9.
  </t>

  <t hangText="Step 13 (step_rcvd_init_failed):"><vspace blankLines="0" />
  For some reason the authentication failed:
  possibly the password or the username is invalid for the authenticated
  resource.  Forget the user-provided credentials for the authentication realm
  and go to Step 12.
  </t>

  <t hangText="Step 14 (step_rcvd_vfy):"><vspace blankLines="0" />
  The received message is the &_200-VFY-S; message, which always contains a &_vks; field.
  Check the validity of the received &_VK_s; value.  If it is equal to the expected value,
  it means that the mutual authentication has succeeded.
  The client will be in the "AUTH-SUCCEEDED" status.
  <vspace blankLines="1" />
  If the value is unexpected, it is a fatal communication error.
  </t>

  <t>
  If a user explicitly requests to log out (via the user interface), the
  client &MUST; forget the user's password, go to step 5, and reload the
  current resource without an authentication header.
  </t>

  <t hangText="Note 1:">These transitions &MAY; be accepted by clients, but are &NOT_RECOMMENDED; for servers to initiate.</t>

</list>
</t>

<t>
<xref target="figure-client-dia" /> shows an informative diagram of the client state.
</t>

<figure anchor="figure-client-dia" title="State diagram for clients"  src="mutual-client-dia.png" alt="">
<artwork><![CDATA[      ===========                                  -(11)------------
      NEW REQUEST                                 ( UNAUTHENTICATED )
      ===========                                  -----------------
           |                                              ^ normal
           v                                              | response
+(1)-------------------+ NO                         +(5)----------+
| The requested URI    |--------------------------->| send normal |
| known to be auth'ed? |                            |   request   |
+----------------------+                            +-------------+
       YES |   401-INIT                            401-INIT|
           |   with a different realm                      |
           |          -----------------------------------. |
           |         /                                   v v
           |        |       -(12)------------    NO  +(6)--------+
           |        |      ( AUTH-REQUESTED  )<------| user/pass |
           |        |       -----------------        |   known?  |
           |        |                                +-----------+
           |        |                                      |YES
           v        |                                      v
     +(2)--------+  |                                +(7)--------+
     | session   |  |                                | session   | NO
 NO /| available?|  |                                | available?|\
   / +-----------+  |                                +-----------+ |
  /        |YES     |                                      |YES    |
 |         |       /|                                      |       |
 |         v      / |  401-                   401-         v       |
 |   +(3)--------+  |  INIT --(13)----------  INIT   +(8)--------+ |
 |   |   send    |--+----->/ AUTH-REQUESTED \<-------|   send    | |
 |  /| req-VFY-C |  |      \forget password /        | req-VFY-C | |
  \/ +-----------+ /        ----------------        /+-----------+ |
  /\           \ \/                 ^ 401-INIT     |     |401-     |
 |  ------      \/\  401-STALE      |              |     | STALE  /
 |        \     /\ -----------------+--------------+---. |       /
 |         |   /  \                 |              |   | |      /
 |         v  /    | 401-           |       401-   |   v v     v
 |   +(4)--------+ | KEX-S1   +(10)-------+ KEX-S1 | +(9)--------+
 |   |   send    |-|--------->|   send    |<-------+-|   send    |
 | --| req-KEX-C1| |          | req-VFY-C |        | | req-KEX-C1|
 |/  +-----------+ |          +-----------+        | +-----------+
 |                 |200-VFY-S      |      200-VFY-S|       ^
 |normal           |               |200-VFY-S     /        |
 |response         |               v             / ==================
 v                  \         -(14)---------    /  USER/PASS INPUTTED
 -(11)------------   ------->( AUTH-SUCCEED )<--   ==================
( UNAUTHENTICATED )           --------------
 -----------------]]>
</artwork>
</figure>

</section>
</section>

<section title="Decision Procedure for Servers" anchor="srv-decision">

<t>
Each server &SHOULD; have a table of session states.
This table need not be persistent over the long term; it &MAY; be cleared
upon server restart, reboot, or for other reasons.
Each entry in the table &SHOULD; contain at least the following information:

<list style="symbols">
  <t>The session identifier, which is the value of the sid parameter.</t>
  <t>The algorithm used.</t>
  <t>The authentication realm.</t>
  <t>The state of the protocol: one of "key exchanging", "authenticated", "rejected", or "inactive".</t>
  <t>The user name received from the client.</t>
  <t>A boolean flag representing whether or not the session is fake.</t>
  <t>When the state is "key exchanging", the values of &_K_c1; and &_S_s1;.</t>
  <t>When the state is "authenticated", the following information:
  <list style="symbols">
    <t>The value of the session secret, z</t>
    <t>The largest nc received from the client (largest-nc)</t>
    <t>For each possible nc values between (largest-nc&nbsp;-&nbsp;nc-window&nbsp;+&nbsp;1) and max_nc,
       a boolean flag whether or not a request with the corresponding nc has been received.
    </t>
  </list>
  </t>
</list>

The table &MAY; contain other information.
</t>

<t>
Servers &SHOULD; respond to the client requests according to the following procedure:
(See Note 1 below for 401-INIT message with a plus sign)

<list style="symbols">
  <t>When the server receives a normal request:
     <list style="symbols">
       <t>If the requested resource is not protected by the Mutual authentication,
          send a normal response.</t>
       <t>If the resource is protected by the Mutual authentication,
          send a &_401-INIT; response.</t>
     </list>
  </t>
  <t>When the server receives a &_req-KEX-C1; request:
     <list style="symbols">
       <t>If the requested resource is not protected by the Mutual authentication,
          send a normal response.</t>
       <t>If the authentication realm specified in the &_req-KEX-C1; request is
          not the expected one, send a &_401-INIT; response.</t>
       <t>If the server cannot validate the parameter &_kc1;, send a &_401-INIT; (+) response.</t>
       <t>If the received user name is either invalid, unknown or unacceptable,
          create a new session, mark it a "fake" session, compute a random value as &_K_s1;, and send a fake &_401-KEX-S1; response. (See Note 2.)
       </t>
       <t>Otherwise, create a new session, compute &_K_s1; and send a &_401-KEX-S1; response.
       The created session is marked as not fake, and its largest-nc is initialized to zero.
</t>
     </list>
     The created session has the "key exchanging" state.
  </t>
  <t>When the server receives a &_req-VFY-C; request:
     <list style="symbols">
       <t>If the requested resource is not protected by the Mutual authentication,
          send a normal response.</t>
       <t>If the authentication realm specified in the &_req-VFY-C; request is
          not the expected one, send a &_401-INIT; response.</t>
     </list>

     If none of above holds true, the server will look up the session
     corresponding to the received sid and the authentication realm.

     <list style="symbols">
       <t>If the session corresponding to the received sid could not
          be found, or it is in the "inactive" state, send a
          &_401-STALE; response.</t>

       <t>If the session is in the "rejected" state,
          send either a &_401-INIT; (+) or a &_401-STALE; message.</t>

       <t>
          If the nc value in the request is larger than the nc-max
          parameter sent from the server, or if it is not larger then
          (largest-nc - nc-window) (when in "authenticated" status),
          the server &MAY; (but is not &REQUIRED; to; See Note 3)
          send a &_401-STALE; message.
          The session &SHOULD; be changed to the "inactive" state if so.
       </t>

       <t>If the session is in the "authenticated" state, and the
          request has an nc value that was previously received from
          the client, send a &_401-STALE; message.  The session
          &SHOULD; be changed to the "inactive" state.
       </t>

       <t>If the session is a "fake" session, or if the received &_vkc;
          is incorrect, then send a &_401-INIT; (+) response.  If the
          session is in the "key exchanging" state, it &SHOULD; be
          changed to the "rejected" state; otherwise, it &MAY; either
          be changed to the "rejected" state or kept in the previous
          state.
       </t>

       <t>Otherwise, send a &_200-VFY-S; response.  If the session was
          in the "key exchanging" state, the session &SHOULD; be
          changed to an "authenticated" state.  The maximum nc and nc
          flags of the state &SHOULD; be updated appropriate.
       </t>
     </list>
  </t>
</list>
</t>

<t>
At any time, the server &MAY; change any state entries with both the
"rejected" and "authenticated" states to the "inactive" status, and
&MAY; discard any "inactive" states from the table.  Entries with
the "key exchanging" state &SHOULD; be kept unless there is an
emergency situation such as a server reboot or a table capacity
overflow.
</t>

<t>
Note 1: In relation with and following the specification of the
optional authentication defined in <xref target="I-D.ietf-httpauth-extension" />,
the &_401-INIT; messages marked with the pluses cannot be 
replaced with a successful responses with an &_Optional-WWW-Authenticate; header.
Every other &_401-INIT; can be a response with an &_Optional-WWW-Authenticate;.
</t>

<t>
Note 2: the server &SHOULD_NOT; send a &_401-INIT; response in this case,
because it will leak the information to the client that the specified user name
will not be accepted. Instead, postpone it to the response for the next req-VFY-C request.
</t>

<t>
Note 3: The next case implies that, when the request is not rejected
under this clause, the server &MUST; be decidable whether the same nc
value was previously received from the client.  If the server does not
remember a whole history of the nc values received from the client,
the server &MUST; send a &_401-STALE; message in this clause.
</t>

</section>

<section title="Authentication Algorithms" anchor="algorithms">

<t>
Cryptographic authentication algorithms which are used with this
protocol will be defined separately. The algorithm definition &MUST;
at least provide definitions for the following functions:
<list style="symbols">
<t>The server-side authentication credential J, derived from client-side authentication credential pi.</t>
<t>Key exchange values &_K_c1;, &_K_s1; (exchanged on wire) and &_S_c1;, &_S_s1; (kept secret in each peer).</t>
<t>Shared secret z, to be computed by both server and client.</t>
<t>A hash function H to be used with the protocol, along with its output size hSize.</t>
<t>The number of iterations for password hashing nIterPi, if it uses the default password hashing function defined below.</t>
</list>
</t>

<t>
Specifications for cryptographic algorithms used with this framework
&MUST; specify whether these will use the default functions defined
below for values pi, &_VK_c;, and &_VK_s;; or, these will define
their own versions for these.  
</t>


<t>
All algorithm used with this protocol &SHOULD; provide secure mutual
authentication between client and servers, and generate a
cryptographically strong shared secret value z, equivalently strong to
or stronger than the hash function H.  If any passwords (or
pass-phrases or any equivalents, i.e., weak secrets) are involved,
these &SHOULD_NOT; be guessable from any data transmitted in the
protocol, even if an attacker (either an eavesdropper or an active
server) knows the possible thoroughly-searchable candidate list of the
passwords.  Furthermore, if possible, the function J for deriving
server-side authentication credential J(pi) is &RECOMMENDED; to be one-way
so that pi should not be easily computed from J(pi).</t>

<!-- t>
The clients &SHOULD; support at least the "&_iso11770-4-dl-2048;"
algorithm, and are advised to support all of the above-mentioned four algorithms whenever possible.
The server software implementations &SHOULD; support at least the "&_iso11770-4-dl-2048;"
algorithm, unless it is known that users will not use it.
</t -->

<section title="Support Functions and Notations">

<t>In this section we define several support functions and notations to be shared by several algorithm definitions.</t>

<t>The integers in the specification are in decimal, or in hexadecimal when prefixed with "0x".</t>

<t>The function octet(i) generates an octet string containing a single octet of value i. 
The operator |, when applied to octet strings, denotes the concatenation of two operands.</t>

<t>The function VI encodes natural numbers into octet strings in the following manner:
numbers are represented as big-endian radix-128 strings,
where each digit is represented by an octet
within the range 0x80&ndash;0xff except the last digit, 
which is represented by a octet within the range 0x00&ndash;0x7f.
The first octet &MUST_NOT; be 0x80.
For example, VI(i) = octet(i) for i &lt; 128,
and VI(i) = octet(0x80 + (i &gt;&gt; 7)) | octet(i &amp; 127) for 128 &lt;= i &lt; 16384.
This encoding is the same as the one used for the sub-components of object identifiers in <xref target="ITU.X690.1994">the ASN.1 encoding</xref>, and available as a "w" conversion in the "pack" function of several scripting languages.
</t>
<t>
The function VS encodes a variable-length octet string into a uniquely-decoded, self-delimited
octet string, as in the following manner:
</t>

<t>
 VS(s) = VI(length(s)) | s
</t>

<t>
where length(s) is a number of octets (not characters) in s.
</t>

<t>
Some examples:
<list>
<t>VI(0) = "\000" (in C string notation)</t>
<t>VI(100) = "d"</t>
<t>VI(10000) = "\316\020"</t>
<t>VI(1000000) = "\275\204@"</t>
</list>
<list>
<t>VS("") = "\000"</t>
<t>VS("Tea") = "\003Tea"</t>
<t>VS("Caf&lt;e acute&gt;" [in UTF-8]) = "\005Caf\303\251"</t>
<t>VS([10000 "a"s]) = "\316\020aaaaa..." (10002 octets)</t>
</list>
</t>

<t>
(Note: Unlike the colon-separated notion used in the
Basic/Digest HTTP authentication scheme, the string generated by a
concatenation of the VS-encoded strings will be unique, regardless
of the characters included in the strings to be encoded.)
</t>

<t>The function OCTETS converts an integer into the corresponding radix-256
big-endian octet string having its natural length.
See <xref target="sec-numbers" /> for the definition of "natural length".
</t>

<t>The function INT converts an octet string into a natural number,
where the input string is treated as being in radix-256 big-endian notation.
The identity INT(OCTETS(n)) = n always holds for any natural number n.
</t>

</section>

<section title="Default Functions for Algorithms">

<t>The functions defined in this section are common default functions among authentication algorithms.
</t>

<t>
The client-side password-based (credential) pi used by this authentication is a
natural number derived in the following manner:
</t>

<t>
   pi = INT(PBKDF2(HMAC_H,
                   ph(password),
                   VS(algorithm) | VS(auth-scope) | VS(realm) | VS(username),
                   nIterPi, hSize / 8)),
</t>

<t>
where
<list style="symbols">
<t> PBKDF2 is the password-based key derivation function defined in <xref target="RFC2898" />,</t>
<t> HMAC_H is the HMAC function, defined in <xref target="RFC2104" />, composed from the hash function H, and</t>
<t> hSize is the output size of hash H in bits.</t>
</list>
</t>

<t>
The values of algorithm, realm, and auth-scope are taken
from the values contained in the &_401-INIT; message.
The function ph is determined by
the value of the pwd-hash parameter given in a &_401-INIT; message.
If the password comes from user input,
it &SHOULD; first be prepared according to the method presented in <xref target="sec-normalize" />.
Then, the password &SHALL; be encoded as a UTF-8 string before being passed to ph.
</t>

<t>
The values &_VK_c; and &_VK_s; are derived by the following equation.
</t>

<t>
 &_VK_c; = INT(H(octet(4) | OCTETS(&_K_c1;) | OCTETS(&_K_s1;) | OCTETS(z) | VI(nc) | VS(vh)))
<vspace blankLines="1" />
 &_VK_s; = INT(H(octet(3) | OCTETS(&_K_c1;) | OCTETS(&_K_s1;) | OCTETS(z) | VI(nc) | VS(vh)))
</t>

</section>

</section>

<section title="Application Channel Binding" anchor="key-provision">

<t>
Applications and upper-layer communication protocols may need authentication binding
to the HTTP-layer authenticated user.  Such applications &MAY; use the following
values as a standard shared secret.
</t>
<t>
These values are parameterized with an optional octet string (t)
which may be arbitrarily chosen by each application or protocol.
If there is no appropriate value to be specified, use an empty string for t.
</t>
<t>
For applications requiring binding to either an authenticated user or a shared-key session (to ensure that
the requesting client is certainly authenticated), the following value b_1 &MAY; be used.
</t>
<t>
 b_1 = H(H(octet(6) | OCTETS(&_K_c1;) | OCTETS(&_K_s1;) | OCTETS(z) | VI(0) | VS(vh)) | VS(t)).
</t>
<t>
For applications requiring binding to a specific request (to ensure that
the payload data is generated for the exact HTTP request), the following value b_2 &MAY; be used.
</t>
<t>
 b_2 = H(H(octet(7) | OCTETS(&_K_c1;) | OCTETS(&_K_s1;) | OCTETS(z) | VI(nc) | VS(vh)) | VS(t)).
</t>
<t>
Note: Channel bindings to lower-layer transports (TCP and TLS) are defined in <xref target="validation" />.
</t>
</section>

<section title="Application for Proxy Authentication">

<t>
The authentication scheme defined by the previous sections can be applied (with modifications) for proxy authentication.
In such cases, the following alterations &MUST; be applied:
<list style="symbols">
<t>The 407 status is to be sent and recognized in places where the 401 status is used,</t>
<t>Proxy-Authenticate header is to be used in places where WWW-Authenticate is used,</t>
<t>Proxy-Authorization  header is to be used in places where Authorization is used,</t>
<t>Proxy-Authentication-Info header is to be used in places where Authentication-Info is used,</t>
<t>The auth-scope parameter is fixed to the host-name of the proxy, which means it covers all requests processed through the specific proxy,</t>
<t>The limitation for the paths contained in the path parameter of &_401-KEX-S1; messages is disregarded,</t>
<t>The omission of the path parameter of &_401-KEX-S1; messages means that the authentication realm will potentially cover all requests processed by the proxy,</t>
<t>The scheme, host name, and the port of the proxy is used for host validation tokens, and</t>
<t>Authentication extensions in <xref target="I-D.ietf-httpauth-extension" /> are not applicable.</t>
</list>
</t>

</section>

<section title="Methods to Extend This Protocol">

<t>
If a private extension to this protocol is implemented,
it &MUST; use the extension-tokens defined in
<xref target="syntax" /> to avoid conflicts with this protocol and other
extensions.
(Standardized or being-standardized extensions &MAY; use either bare-tokens or extension-tokens.)
</t>

<t>
Specifications defining authentication algorithms &MAY; use other
representations for the parameters "&_kc1;", "&_ks1;", "&_vkc;", and
"&_vks;", replace those parameter names, and/or add parameters to the messages
containing those parameters in supplemental specifications, provided
that syntactic and semantic requirements in <xref target="syntax" />,
<xref target="RFC7230" /> and <xref
target="RFC7235" /> are satisfied.  Any parameters
starting with "kc", "ks", "vkc" or "vks" and followed by decimal
natural numbers (e.g.&nbsp;kc2, ks0, vkc1, vks3 etc.) are reserved for
this purpose.  If those specifications use names other than those
mentioned above, it is &RECOMMENDED; to use extension-tokens to avoid
any parameter name conflict with future extensions to this protocol.
</t>

<t>
Extension-tokens &MAY; be freely used for any non-standard,
private, and/or experimental uses for those parameters provided that the
domain part in the token is used in the manner defined in <xref target="syntax" />.
</t>

</section>

<section anchor="IANA" title="IANA Considerations">
<t>When bare-tokens are used for the authentication-algorithm, pwd-hash, and
validation parameters, these &MUST; be allocated by IANA.
To acquire registered tokens, a specification for the use of such tokens &MUST; be reviewed by
a designated expert, as outlined in <xref target="RFC5226" />.
</t>

<section title="Registry for Authentication Algorithms">
<t>
This document establishes a registry for HTTP Mutual authentication algorithms.
The registry manages case-insensitive ASCII strings.  The strings &MUST; follow
the extensive-token syntax defined in <xref target="syntax" />.
</t>

<t>
Registrations for an authentication algorithm are required to include a
description of the authentication algorithms.  Reviewers assigned by
IESG are advised to examine minimum security requirements and
consistency of the key exchange algorithm descriptions.
</t>

<t>
New registrations are advised to provide the following information:
<list style="symbols">
<t>Token: a token used in HTTP headers for identifying the algorithm.</t>
<t>Description: A brief description of the algorithm.</t>
<t>Specification: A reference for a specification defining the algorithm.</t>
</list>
</t>

<t>
The initial content of this registry is empty. [[Editorial Note: A separate document <xref target="I-D.ietf-httpauth-mutual-algo" /> will effectively define the initial content of the registry.]]
</t>

</section>

<section title="Registry for Password Hash Algorithms">
<t>
This document establishes a registry for HTTP Mutual authentication password hash algorithms.
The registry manages case-insensitive ASCII strings.  The strings &MUST; follow
the extensive-token syntax defined in <xref target="syntax" />.
</t>

<t>
Registrations for authentication algorithms are required to include a
description of the key exchange algorithms.  Reviewers assigned by
IESG are advised to examine its use-case requirements and security consequence of its introduction.
</t>

<t>
New registrations are advised to provide the following information:
<list style="symbols">
<t>Token: a token used in HTTP headers for identifying the algorithm.</t>
<t>Description: A brief description of the algorithm.</t>
<t>Specification: A reference for a specification defining the algorithm.</t>
</list>
</t>

<t>
The initial content of this registry is as follows:
</t>
<texttable>
<ttcol>Token</ttcol><ttcol>Description</ttcol><ttcol>Specification</ttcol>
<c>none      </c><c>No additional hashing, recommended</c><c><xref target="401-INIT" /></c>
<c>md5       </c><c>MD5-based preprocessing</c><c><xref target="401-INIT" /></c>
<c>sha1      </c><c>SHA1-based preprocessing</c><c><xref target="401-INIT" /></c>
</texttable>

</section>

<section title="Registry for Validation Methods">
<t>
This document establishes a registry for HTTP Mutual authentication host validation methods.
The registry manages case-insensitive ASCII strings.  The strings &MUST; follow
the extensive-token syntax defined in <xref target="syntax" />.
</t>

<t>
Registrations for a validation method are required to include a
description of the validation method.  Reviewers assigned by
IESG are advised to examine its use-case requirements and security consequence of its introduction.
</t>

<t>
New registrations are advised to provide the following information:
<list style="symbols">
<t>Token: a token used in HTTP headers for identifying the method.</t>
<t>Description: A brief description of the method.</t>
<t>Specification: A reference for a specification defining the method.</t>
</list>
</t>

<t>
The initial content of this registry is as follows:
</t>
<texttable>
<ttcol>Token</ttcol><ttcol>Description</ttcol><ttcol>Specification</ttcol>
<c>host      </c><c>Host name verification only</c><c><xref target="validation" /></c>
<c>tls-server-end-point</c><c>TLS certificate-based</c><c><xref target="validation" /></c>
<c>tls-unique</c><c>TLS unique key-based</c><c><xref target="validation" /></c>
</texttable>

</section>


</section>

<section anchor="Security" title="Security Considerations">

<section title="Security Properties">

<t>
<list style="symbols">
 <t>
  The protocol is secure against passive eavesdropping and replay attacks.
  However, the protocol relies on transport security including DNS integrity
  for data secrecy and integrity.
  HTTP/TLS &SHOULD; be used where transport security
  is not assured and/or data confidentiality is important.
 </t>

 <t>
  When used with HTTP/TLS, if TLS server certificates are reliably
  verified, the protocol provides true protection against active
  man-in-the-middle attacks.
 </t>

 <t>
  Even if the server certificate is not used or is unreliable, the
  protocol provides protection against active man-in-the-middle attacks
  for each HTTP request/response pair.  However, in such cases,
  JavaScript or similar scripting facilities can be used to affect the
  Mutually-authenticated contents from other contents not protected by this
  authentication mechanism.  This is the reason why this protocol requires that valid
  TLS server certificates &MUST; be presented (<xref target="validation" />).
 </t>
</list>
</t>
</section>

<section title="Denial-of-service Attacks to Servers">

<t>
 The protocol requires a server-side table of active sessions, which
 may become a critical point for server resource consumption.
 For proper operation, the protocol requires that at least one 
 key verification request is processed for each session identifier.
 After that, servers &MAY; discard sessions internally at any time,
 without causing any operational problems to clients.  Clients will
 silently reestablish a new session then.
</t>

<t>
 However, if a malicious client sends too many requests for key
 exchanges (&_req-KEX-C1; messages) only, resource starvation might occur.
 In such critical situations, servers &MAY; discard any kind of
 existing sessions regardless of their statuses.  One way to mitigate
 such attacks is that servers &MAY; have a number and a time limit for
 unverified, pending key exchange requests (in the "key exchanging" state).
</t>

<t>
This is a common weakness of authentication protocols with almost any
kind of negotiations or states, including Digest authentication scheme
and most Cookie-based authentication implementations.  However,
regarding the resource consumption, the situation for the mutual
authentication scheme is a slightly better than for Digest, because
HTTP requests without any kind of authentication requests will not
generate any kind of sessions.  Session identifiers are only generated
after a client starts a key negotiation.  It means that simple clients
such as Web crawlers will not accidentally consume server-side
resources for session managements.
</t>

<section title="On-line Active Password Attacks">

<t>
Although the protocol provides very strong protection against
off-line dictionary attacks from eavesdropped traffic,
the protocol, by its nature, cannot prevent active
password attacks in which the attackers sends so many authentication
trial requests for every possible password.
</t>
<t>
Possible countermeasures for preventing such attacks may be 
rate-limiting of password authentication trials,
statistics-based intrusion detection measures, or
similar protection schemes.  If the server operators
assume that the passwords of users are not strong enough,
it may be desirable to introduce such ad-hoc countermeasures.
</t>
</section>

</section>

<section title="Communicating the status of mutual authentication with users">

<t>
  This protocol is designed for two goals. The first goal is just providing
  a secure alternative for existing Basic and Digest authentication.
  The second goal is to provide users a way to detect forged rogue servers
  imitating a user's registered account on a server, commonly known
  as (a part or kind of) Phishing attacks.
</t>

<t>
  For this protocol to effectively work as some countermeasure to
  such attacks, it is very important that end users of clients be
  notified of the result of the mutual authentication performed by this protocol,
  especially the three states "AUTH-SUCCEED", "UNAUTHENTICATED", and
  "AUTH-REQUIRED" defined in <xref target="cli-decision" />.
  The design of secure user interfaces of the HTTP interactive clients
  is out of the scope of this document, but if possible,
  having some kind of UI indication for the three states above will
  be desirable for the user's security benefit.
</t>

<t>
  Of course, in such cases, the user interfaces for asking passwords
  for this authentication shall be clearly identifiable against
  imitation by other insecure password input fields (such as forms).
  If the passwords are known to malicious attackers outside of the
  protocol, the protocol cannot work as an effective security measures.
</t>

</section>

<section title="Implementation Considerations">

<t>
<list style="symbols">
 <t>   To securely implement the protocol, the &_Authentication-Info;
       headers in the &_200-VFY-S; messages &MUST; always be validated by the
       client. If the validation fails, the client &MUST_NOT; process
       any content sent with the message, including other headers and the body part.
       Non-compliance to this requirement will allow phishing attacks.
</t>

<t>
       For HTTP/TLS communications, when a web form is submitted from
       Mutually-authenticated pages with the "&_tls-server-end-point;" validation method
       to a URI that is protected by the same realm (so
       indicated by the path parameter), if the server certificate
       has been changed since the pages were received, the peer
       is &RECOMMENDED; to be re-validated using a &_req-KEX-C1; message with an
       "Expect: &_100-continue;" header.  The same applies when the
       page is received with the "&_tls-unique;" validation method, and
       when the TLS session has expired.
</t>

<t>
       For better protection against possible password database stealing,
       server-side storage of user passwords should contain
       the values encrypted by the one-way function J(pi),
       instead of the real passwords, those hashed by ph, or pi.
</t>
</list>
</t>
</section>


<section title="Usage Considerations" anchor="sec-usage">

<t>
<list style="symbols">
 <t>
  The user names inputted by a user may be sent automatically to any servers
  sharing the same auth-scope.  This means that when a host-type auth-scope
  is used for authentication on an HTTPS site, and when an HTTP server on the
  same host requests Mutual authentication within the same realm, 
  the client will send the user name in clear text.
  If user names have to be kept secret against eavesdropping,
  the server must use the full-scheme-type auth-scope parameter and HTTPS.
  Contrarily, passwords are not exposed to eavesdroppers even on HTTP requests.
 </t>
 <t>
  The "pwd-hash" parameter is only provided for backward compatibility
  of password databases with values already hashed with older hash algorithms.
  For any new databases, the use of the "none" function is the most secure choice
  and is &RECOMMENDED;.
  For this reason, any modern hash functions like SHA-2 or SHA-3 is not supported here.
  If values other than "none" are used, you &MUST; ensure that
  the hash values of the passwords were not exposed to the public.
  Note that hashed password databases for plain-text authentication
  are usually not considered secret.
 </t>
<t>
       If the server provides several ways for storing server-side
       password secrets in the password database, it is desirable for
       better security to store the values encrypted by using the one-way function J(pi),
       instead of the real passwords, those hashed by ph, or pi.
</t>
</list>
</t>

</section>

</section>

<section title="Notice on Intellectual Properties">

<t>
The National Institute of Advanced Industrial Science and Technology (AIST) and
Yahoo! Japan, Inc. have jointly submitted a patent application
to the Patent Office of Japan for the protocol proposed in this documentation.
The patent is intended to be open to any implementer of this protocol
and its variants under non-exclusive royalty-free terms.
For the details of the patent application and its status,
please contact the authors of this document.
</t>

<t>
The elliptic-curve based authentication algorithms might involve several
existing third-party patents.  The authors of the document take no
position regarding the validity or scope of such patents and other patents
as well.
</t>

</section>

</middle>


  <!--  *****BACK MATTER ***** -->


  <back>
    <references title="Normative References">
      &RFC2104;

      &RFC2119;

      &RFC2898;

      &RFC3629;

      &RFC4648;

      &RFC5234;

      &RFC5246;

      &RFC5987;

      &RFC7230;

      &RFC7235;

      &RFC7613;

      &RFC7615;

      &I-D.ietf-httpauth-extension;

    </references>

    <references title="Informative References">

      &I-D.ietf-httpauth-mutual-algo;

      &RFC1939;

      &RFC2818;

      &RFC5226;

      &RFC5890;

      &RFC5929;

      &RFC6265;

      &RFC6454;

      &RFC7564;

      &RFC7616;

      &ITU.X690.1994;

      &ISO.10646-1.1993;

      &RFC7627;

    </references>

    <section anchor="changelog" title="(Informative) Draft Change Log">
      <section title="Changes in Httpauth WG Revision 06">
	<t>
          <list style="symbols">
	    <t>The auth-domain parameter has been renamed to auth-scope, following suggestions on the mailing list.</t>
	    <t>The digest-md5 password-hash has been dropped, as Digest with MD5 hash is now obsoleted.</t>
	  </list>
        </t>
      </section>
      <section title="Changes in Httpauth WG Revision 05">
	<t>
          <list style="symbols">
	    <t>Minimum nonce number window has increased to 128.
	    (HTTP 2.0 recommends at least 100 concurrent sessions to exist)</t>
	    <t>Reference to TLS session hash extension added for tls-unique security issues.</t>
	    <t>Comments in the previous F2F meeting has been reflected to the text.</t>
	  </list>
        </t>
      </section>
      <section title="Changes in Httpauth WG Revision 04">
	<t>
          <list style="symbols">
	    <t>Merged httpauthprep proposal into general PRECIS Username/Password profile.</t>
	    <t>Adopting RFC 5987 extended syntax for non-ASCII parameter values.</t>
	    <t>Refer draft-ietf-httpbis-auth-info for Authentication-Info header.
               This results in a different syntax for that header.</t>
	  </list>
        </t>
      </section>
      <section title="Changes in Httpauth WG Revision 03">
	<t>
          <list style="symbols">
	    <t>Incompatible change: Single-port type authentication realm label has been changed to harmonize with Web Origin. (That is, the default ports (80 and 443) are to be omitted.)</t>
	  </list>
        </t>
      </section>
      <section title="Changes in Httpauth WG Revision 02">
	<t>
          <list style="symbols">
	    <t>Major change: introduction of password-strengthening function PBKDF2.</t>
	    <t>Changed <xref target="cli-decision" /> to adopt "list of requirements" style.
	       Strict definition of state machine is now a derived, informational definition.</t>
	  </list>
        </t>
      </section>
      <section title="Changes in Httpauth WG Revision 01">
	<t>
          <list style="symbols">
	    <t>Changed "tls-key" verification to "tls-unique" verification, and "tls-cert" to "tls-server-end-point", adopting RFC 5929.</t>
	    <t>Adopted <xref target="RFC7564">PRECIS framework</xref>.</t>
	    <t>Reverted reservation of "rekey-sid" and "rekey-method" parameters.</t>
	    <t>Degraded secure UI requirement to application note level, non-normative.</t>
	    <t>Adjusted levels of several requirements.</t>
	    <t>Added warning text for handling of exceptional 5XX responses.</t>
	    <t>Dropped several references for optional authentications, except one "Note".</t>
	    <t>Several textual fixes, improvements and revisions.</t>
	  </list>
        </t>
      </section>
      <section title="Changes in Httpauth Revision 00">
	<t>
          <list style="symbols">
	    <t>Changed the version token.</t>
	    <t>Renamed "verification tokens" to "Host verification tokens" and variables "v" to "vh" for clarification.  (Back-ported from draft-oiwa-httpauth-multihop-template-00)</t>
	  </list>
        </t>
      </section>
      <section title="Changes in HttpBis Revision 00">
	<t>None.</t>
      </section>
      <section title="Changes in Revision 12">
	<t>
          <list style="symbols">
	    <t>Added a reason "authz-failed".</t>
	  </list>
        </t>
      </section>
      <section title="Changes in Revision 11">
	<t>
          <list style="symbols">
	    <t>Message syntax definition reverted to pre-07 style as httpbis-p1 and p7 now defines a precise rule for parameter value parsing.</t>
	    <t>Replaced "stale" parameter with more informative/extensive "reason" parameter in 401-INIT and 401-STALE.</t>
	    <t>Reserved "rekey-sid" and "rekey-method" parameters for future extensions.</t>
	    <t>Added descriptions for replacing/non-replacing existing technologies.</t>
	  </list>
        </t>
      </section>
      <section title="Changes in Revision 10">
        <t>
          <list style="symbols">
            <t>The authentication extension parts (non-mandatory authentication and authentication controls) are separated to yet another draft.</t>
	    <t>The default auth-domain parameter is changed to the full scheme-host-port syntax, which is consistent with usual HTTP authentication framework behavior.</t>
	    <t>Provision for application channel binding is added.</t>
	    <t>Provision for proxy access authentication is added.</t>
	    <t>Bug fix: syntax specification of sid parameter was wrong: it was inconsistent with the type specified in the main text (the bug introduced in -07 draft).</t>
	    <t>Terminologies for headers are changed to be in harmony with httpbis drafts (e.g. field to parameter).</t>
	    <t>Syntax definitions are changed to use HTTP-extended ABNF syntax, and only the header values are shown for header syntax, in harmony with httpbis drafts.</t>
	    <t>Names of parameters and corresponding mathematical values are now renamed to more informative ones. The following list shows correspondence between the new and the old names.
            </t>
	   </list>
        </t>
               <texttable>
	         <ttcol>new name</ttcol>
                 <ttcol>old name</ttcol>
                 <ttcol>description</ttcol>

	         <c>&_S_c1;, &_S_s1;</c><c>s_a, s_b</c><c>client/server-side secret randoms</c>
		 <c>&_K_c1;, &_K_s1;</c><c>w_a, w_b</c><c>client/server-side exchanged key components</c>
		 <c>&_kc1;, &_ks1;</c><c>wa, wb</c><c>parameter names for those</c>
		 <c>&_VK_c;, &_VK_s;</c><c>o_a, o_b</c><c>client/server-side key verifiers</c>
		 <c>&_vkc;, &_vks;</c><c>oa, ob</c><c>parameter names for those</c>
		 <c>z</c><c>z</c><c>session secrets</c>
                </texttable>
      </section>
      <section title="Changes in Revision 09">
        <t>
          <list style="symbols">
            <t>The (default) cryptographic algorithms are separated to another draft.</t>
	    <t>Names of the messages are changed to more informative ones than before.  The following is the correspondence table of those names:</t>
	   </list>
        </t>
               <texttable>
	         <ttcol>new name</ttcol>
                 <ttcol>old name</ttcol>
                 <ttcol>description</ttcol>

	         <c>401-INIT</c><c>401-B0</c><c>initial response</c>
		 <c>401-STALE</c><c>401-B0-stale</c><c>session key expired</c>
		 <c>req-KEX-C1</c><c>req-A1</c><c>client-&gt;server key exchange</c>
		 <c>401-KEX-S1</c><c>401-B1</c><c>server-&gt;client key exchange</c>
		 <c>req-VFY-C</c><c>req-A3</c><c>client-&gt;server auth. verification</c>
		 <c>200-VFY-S</c><c>200-B4</c><c>server-&gt;client auth. verification</c>
	         <c>200-Optional-INIT</c><c>200-Optional-B0</c><c>initial with non-mandatory authentication</c>
              </texttable>
      </section>
      <section title="Changes in Revision 08">
        <t>
          <list style="symbols">
            <t>The English text has been revised.
            </t>
	   </list>
        </t>
      </section>
      <section title="Changes in Revision 07">
        <t>
          <list style="symbols">
            <t>Adapt to httpbis HTTP/1.1 drafts:
	    <list>
	    <t>Changed definition of extensive-token.</t>
	    <t>LWSP continuation-line (%0D.0A.20) deprecated.</t>
            </list>
	    </t>
	    <t>To simplify the whole spec, the type of nonce-counter related parameters are change from hex-integer to integer.
	    </t>
	    <t>
            Algorithm tokens are renamed to include names of hash algorithms.
            </t>
	    <t>
            Clarified the session management, added details of server-side protocol decisions.
            </t>
            <t>
            The whole draft was reorganized; introduction and overview has been rewritten.
            </t>
	   </list>
        </t>
      </section>
      <section title="Changes in Revision 06">
        <t>
          <list style="symbols">
            <t>Integrated Optional Mutual Authentication to the main part.</t>
            <t>Clarified the decision procedure for message recognitions.</t>
	    <t>Clarified that a new authentication request for any sub-requests
               in interactive clients may be silently discarded.</t>
            <t>Typos and confusing phrases are fixed.</t>
            <t>Several "future considerations" are added.</t>
          </list>
        </t>
      </section>
      <section title="Changes in Revision 05">
        <t>
          <list style="symbols">
            <t>A new parameter called "version" is added for supporting future incompatible changes with a single implementation.
               In the (first) final specification its value will be changed to 1.</t>
            <t>A new header "&_Authentication-Control;" is added for precise control of application-level authentication behavior.</t>
          </list>
        </t>
      </section>
      <section title="Changes in Revision 04">
        <t>
          <list style="symbols">
            <t>Changed text of patent licenses: the phrase
               "once the protocol is accepted as an Internet standard" is removed
               so that the sentence also covers the draft versions of this protocol.</t>
            <t>The "tls-key" verification is now &OPTIONAL;.</t>
	    <t>Several description fixes and clarifications.</t>
          </list>
        </t>
      </section>
      <section title="Changes in Revision 03">
        <t>
          <list style="symbols">
            <t>Wildcard domain specifications (e.g. "*.example.com") are allowed for auth-domain parameters (<xref target="401-INIT" />).</t>
	    <t>Specification of the tls-cert verification is updated (incompatible change).</t>
            <t>State transitions fixed.</t>
            <t>Requirements for servers concerning w_a values are clarified.</t>
            <t>RFC references are updated.</t>
          </list>
        </t>
      </section>
      <section title="Changes in Revision 02">
        <t>
          <list style="symbols">
            <t>Auth-realm is extended to allow full-scheme type.</t>
            <t>A decision diagram for clients and decision procedures for servers are added.</t>
            <t>401-B1 and req-A3 messages are changed to contain authentication realm information.</t>
	    <t>Bugs on equations for o_A and o_B are fixed.</t>
	    <t>Detailed equations for the entire algorithm are included.</t>
	    <t>Elliptic-curve algorithms are updated.</t>
            <t>Several clarifications and other minor updates.</t>
          </list>
        </t>
      </section>
      <section title="Changes in Revision 01">
        <t>
          <list style="symbols">
            <t>Several texts are rewritten for clarification.</t>
	    <t>Added several security consideration clauses.</t>
	  </list>
        </t>
      </section>
    </section>

  </back>
</rfc>

<!--  LocalWords:  interoperability implementers boolean
 -->
